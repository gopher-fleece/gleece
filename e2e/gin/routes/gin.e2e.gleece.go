/*
--
This file is automatically generated. Any manual changes to this file may be overwritten.
It includes routes and handlers by the Gleece API Routes Generator.
--
Authors: Haim Kastner & Yuval Pomerchik
Generated by: Gleece Routes Generator
Generated Date: 2025-03-02
Target Engine: Gin (https://github.com/gin-gonic/gin)
--
Usage:
Refer to the Gleece documentation for details on how to use the generated routes and handlers.
--
Repository: https://github.com/gopher-fleece/gleece
--
*/
package routes
import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/textproto"
	"regexp"
	"strings"
	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
	RequestAuth "github.com/gopher-fleece/gleece/e2e/gin/auth"
	"github.com/gopher-fleece/runtime"
	E2EControllerImport "github.com/gopher-fleece/gleece/e2e/assets"
	Param33theBody "github.com/gopher-fleece/gleece/e2e/assets"
	Param38theBody "github.com/gopher-fleece/gleece/e2e/assets"
	Param41theBody "github.com/gopher-fleece/gleece/e2e/assets"
	Response62CustomError "github.com/gopher-fleece/gleece/e2e/assets"
	Response65CustomError "github.com/gopher-fleece/gleece/e2e/assets"
	E2EClassSecControllerImport "github.com/gopher-fleece/gleece/e2e/assets"
	// ImportsExtension - test
)
var validatorInstance = validator.New()
var urlParamRegex *regexp.Regexp
type SecurityListRelation string
const (
	SecurityListRelationAnd SecurityListRelation = "AND"
)
type SecurityCheckList struct {
	Checks   []runtime.SecurityCheck
	Relation SecurityListRelation
}
// TypeDeclarationsExtension - test
func extractValidationErrorMessage(err error, fieldName *string) string {
	if err == nil {
		return ""
	}
	validationErrors, ok := err.(validator.ValidationErrors)
	if !ok {
		return err.Error()
	}
	var errStr string
	for _, validationErr := range validationErrors {
		fName := validationErr.Field()
		if fieldName != nil {
			fName = *fieldName
		}
		errStr += fmt.Sprintf("Field '%s' failed validation with tag '%s'. ", fName, validationErr.Tag())
	}
	return errStr
}
func getStatusCode(controller runtime.Controller, hasReturnValue bool, err error) int {
	if controller.GetStatus() != nil {
		return int(*controller.GetStatus())
	}
	if err != nil {
		return http.StatusInternalServerError
	}
	if hasReturnValue {
		return http.StatusOK
	}
	return http.StatusNoContent
}
func bindAndValidateBody[TOutput any](ctx *gin.Context, contentType string, validation string, output **TOutput) error {
	var err error
	bodyBytes, err := io.ReadAll(ctx.Request.Body)
	if err != nil || len(bodyBytes) == 0 {
		if strings.Contains(validation, "required") {
			return fmt.Errorf("body is required but was not provided")
		}
		return nil
	}
	var deserializedOutput TOutput
	switch contentType {
	case "application/json":
		err = json.Unmarshal(bodyBytes, &deserializedOutput)
	default:
		return fmt.Errorf("content-type %s is not currently supported by the validation subsystem", contentType)
	}
	if err != nil {
		return err
	}
	if err = validatorInstance.Struct(&deserializedOutput); err != nil {
		return err
	}
	*output = &deserializedOutput
	return nil
}
func toGinUrl(url string) string {
	processedUrl := urlParamRegex.ReplaceAllString(url, ":$1")
	processedUrl = strings.ReplaceAll(processedUrl, "//", "/")
	if processedUrl == "" {
		return "/"
	}
	if !strings.HasPrefix(processedUrl, "/") {
		processedUrl = "/" + processedUrl
	}
	return processedUrl
}
func authorize(ctx *gin.Context, checksLists []SecurityCheckList) *runtime.SecurityError {
	var lastError *runtime.SecurityError
	for _, list := range checksLists {
		if list.Relation != SecurityListRelationAnd {
			panic(
				"Encountered a security list relation of type '%s' - this is unexpected and indicates a bug in Gleece itself." +
					"Please open an issue at https://github.com/gopher-fleece/gleece/issues",
			)
		}
		// Iterate over each security list
		encounteredErrorInList := false
		for _, check := range list.Checks {
			secErr := RequestAuth.GleeceRequestAuthorization(ctx, check)
			if secErr != nil {
				lastError = secErr
				encounteredErrorInList = true
				break
			}
		}
		// If no error was encountered, validation is considered successful
		// otherwise, we continue over to the next iteration whilst keeping track of the last error
		if !encounteredErrorInList {
			return nil
		}
	}
	// If we got here it means authentication has failed
	return lastError
}
func handleAuthorizationError(ctx *gin.Context, authErr *runtime.SecurityError, operationId string) {
	statusCode := int(authErr.StatusCode)
	if authErr.CustomError != nil {
		// For now, we support JSON only
		ctx.JSON(statusCode, authErr.CustomError.Payload)
		return
	}
	stdError := runtime.Rfc7807Error{
		Type:     http.StatusText(statusCode),
		Detail:   authErr.Message,
		Status:   statusCode,
		Instance: "/gleece/authorization/error/" + operationId,
	}
	ctx.JSON(statusCode, stdError)
}
func wrapValidatorError(validatorErr error, operationId string, fieldName string) runtime.Rfc7807Error {
	return runtime.Rfc7807Error{
		Type: http.StatusText(http.StatusUnprocessableEntity),
		Detail: fmt.Sprintf(
			"A request was made to operation '%s' but parameter '%s' did not pass validation - %s",
			operationId,
			fieldName,
			extractValidationErrorMessage(validatorErr, &fieldName),
		),
		Status:   http.StatusUnprocessableEntity,
		Instance: fmt.Sprintf("/gleece/validation/error/%s", operationId),
	}
}
// FunctionDeclarationsExtension - test
type MiddlewareFunc func(ctx *gin.Context) bool
type ErrorMiddlewareFunc func(ctx *gin.Context, err error) bool
var beforeOperationMiddlewares []MiddlewareFunc
var afterOperationSuccessMiddlewares []MiddlewareFunc
var onErrorMiddlewares []ErrorMiddlewareFunc
var onInputValidationMiddlewares []ErrorMiddlewareFunc
var onOutputValidationMiddlewares []ErrorMiddlewareFunc
func RegisterMiddleware(executionType runtime.MiddlewareExecutionType, middlewareFunc MiddlewareFunc) {
	switch executionType {
	case runtime.BeforeOperation:
		beforeOperationMiddlewares = append(beforeOperationMiddlewares, middlewareFunc)
	case runtime.AfterOperationSuccess:
		afterOperationSuccessMiddlewares = append(afterOperationSuccessMiddlewares, middlewareFunc)
	}
}
func RegisterErrorMiddleware(executionType runtime.ErrorMiddlewareExecutionType, errorMiddlewareFunc ErrorMiddlewareFunc) {
	switch executionType {
	case runtime.OnInputValidationError:
		onInputValidationMiddlewares = append(onInputValidationMiddlewares, errorMiddlewareFunc)
	case runtime.OnOutputValidationError:
		onOutputValidationMiddlewares = append(onOutputValidationMiddlewares, errorMiddlewareFunc)
	case runtime.OnOperationError:
		onErrorMiddlewares = append(onErrorMiddlewares, errorMiddlewareFunc)
	}
}
func RegisterCustomValidator(validateTagName string, validateFunc runtime.ValidationFunc) {
	validatorInstance.RegisterValidation(validateTagName, func(fl validator.FieldLevel) bool {
		return validateFunc(fl)
	})
}
func RegisterRoutes(engine *gin.Engine) {
	urlParamRegex = regexp.MustCompile(`\{([\w\d-_]+)\}`)
	// RegisterRoutesExtension - test
	// E2EController
	engine.GET(toGinUrl("/e2e/simple-get"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "SimpleGet")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "SimpleGet")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "SimpleGet")
		value, opError := controller.SimpleGet()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "SimpleGet")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGet'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGet",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "SimpleGet")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "SimpleGet")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "SimpleGet")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "SimpleGet")
	})
	engine.GET(toGinUrl("/e2e/simple-get-empty-string"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "SimpleGetEmptyString")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "SimpleGetEmptyString")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "SimpleGetEmptyString")
		value, opError := controller.SimpleGetEmptyString()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "SimpleGetEmptyString")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetEmptyString'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetEmptyString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "SimpleGetEmptyString")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "SimpleGetEmptyString")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "SimpleGetEmptyString")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "SimpleGetEmptyString")
	})
	engine.GET(toGinUrl("/e2e/simple-get-ptr-string"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "SimpleGetPtrString")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "SimpleGetPtrString")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "SimpleGetPtrString")
		value, opError := controller.SimpleGetPtrString()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "SimpleGetPtrString")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetPtrString'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetPtrString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "SimpleGetPtrString")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "SimpleGetPtrString")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "SimpleGetPtrString")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "SimpleGetPtrString")
	})
	engine.GET(toGinUrl("/e2e/simple-get-null-string"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "SimpleGetNullString")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "SimpleGetNullString")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "SimpleGetNullString")
		value, opError := controller.SimpleGetNullString()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "SimpleGetNullString")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetNullString'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetNullString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "SimpleGetNullString")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "SimpleGetNullString")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "SimpleGetNullString")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "SimpleGetNullString")
	})
	engine.GET(toGinUrl("/e2e/simple-get-object"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "SimpleGetObject")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "SimpleGetObject")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "SimpleGetObject")
		value, opError := controller.SimpleGetObject()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "SimpleGetObject")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObject'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetObject",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "SimpleGetObject")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "SimpleGetObject")
		var outputValidationErr error
		outputValidationErr = validatorInstance.Struct(value)
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObject'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/SimpleGetObject",
				Extensions: map[string]string{},
			}
			ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "SimpleGetObject")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "SimpleGetObject")
	})
	engine.GET(toGinUrl("/e2e/simple-get-object-ptr"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "SimpleGetObjectPtr")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "SimpleGetObjectPtr")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "SimpleGetObjectPtr")
		value, opError := controller.SimpleGetObjectPtr()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "SimpleGetObjectPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectPtr'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetObjectPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "SimpleGetObjectPtr")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "SimpleGetObjectPtr")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validatorInstance.Struct(value)
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectPtr'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/SimpleGetObjectPtr",
				Extensions: map[string]string{},
			}
			ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "SimpleGetObjectPtr")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "SimpleGetObjectPtr")
	})
	engine.GET(toGinUrl("/e2e/simple-get-object-null"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "SimpleGetObjectNull")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "SimpleGetObjectNull")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "SimpleGetObjectNull")
		value, opError := controller.SimpleGetObjectNull()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "SimpleGetObjectNull")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectNull'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetObjectNull",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "SimpleGetObjectNull")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "SimpleGetObjectNull")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validatorInstance.Struct(value)
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectNull'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/SimpleGetObjectNull",
				Extensions: map[string]string{},
			}
			ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "SimpleGetObjectNull")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "SimpleGetObjectNull")
	})
	engine.GET(toGinUrl("/e2e/simple-get-empty"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "SimpleGetEmpty")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "SimpleGetEmpty")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var queryParamRawPtr *string = nil
		queryParamRaw, isqueryParamExists := ctx.GetQuery("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "SimpleGetEmpty", fieldName)
			ctx.Header("x-RunValidatorExtension", "SimpleGetEmpty")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "SimpleGetEmpty")
		opError := controller.SimpleGetEmpty(*queryParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "SimpleGetEmpty")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetEmpty'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetEmpty",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "SimpleGetEmpty")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "SimpleGetEmpty")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "SimpleGetEmpty")
		ctx.Status(statusCode)
		ctx.Header("x-RouteEndRoutesExtension", "SimpleGetEmpty")
	})
	engine.GET(toGinUrl("/e2e/get-with-all-params/{pathParam}"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "GetWithAllParams")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "GetWithAllParams")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var queryParamRawPtr *string = nil
		queryParamRaw, isqueryParamExists := ctx.GetQuery("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParams", fieldName)
			ctx.Header("x-RunValidatorExtension", "GetWithAllParams")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var pathParamRawPtr *string = nil
		pathParamRaw, ispathParamExists := ctx.Params.Get("pathParam")
		if ispathParamExists {
			pathParam := pathParamRaw
			pathParamRawPtr = &pathParam
		}
		if validatorErr := validatorInstance.Var(pathParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "pathParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParams", fieldName)
			ctx.Header("x-RunValidatorExtension", "GetWithAllParams")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.GetHeader("headerParam")
		_, isheaderParamExists := ctx.Request.Header[textproto.CanonicalMIMEHeaderKey("headerParam")]
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParams", fieldName)
			ctx.Header("x-RunValidatorExtension", "GetWithAllParams")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "GetWithAllParams")
		value, opError := controller.GetWithAllParams(*queryParamRawPtr, *pathParamRawPtr, *headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "GetWithAllParams")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetWithAllParams'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/GetWithAllParams",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "GetWithAllParams")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "GetWithAllParams")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "GetWithAllParams")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "GetWithAllParams")
	})
	engine.GET(toGinUrl("/e2e/get-with-all-params-ptr/{pathParam}"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "GetWithAllParamsPtr")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "GetWithAllParamsPtr")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var queryParamRawPtr *string = nil
		queryParamRaw, isqueryParamExists := ctx.GetQuery("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		var pathParamRawPtr *string = nil
		pathParamRaw, ispathParamExists := ctx.Params.Get("pathParam")
		if ispathParamExists {
			pathParam := pathParamRaw
			pathParamRawPtr = &pathParam
		}
		if validatorErr := validatorInstance.Var(pathParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "pathParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsPtr", fieldName)
			ctx.Header("x-RunValidatorExtension", "GetWithAllParamsPtr")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.GetHeader("headerParam")
		_, isheaderParamExists := ctx.Request.Header[textproto.CanonicalMIMEHeaderKey("headerParam")]
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "GetWithAllParamsPtr")
		value, opError := controller.GetWithAllParamsPtr(queryParamRawPtr, pathParamRawPtr, headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "GetWithAllParamsPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetWithAllParamsPtr'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/GetWithAllParamsPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "GetWithAllParamsPtr")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "GetWithAllParamsPtr")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "GetWithAllParamsPtr")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "GetWithAllParamsPtr")
	})
	engine.GET(toGinUrl("/e2e/get-with-all-params-required-ptr/{pathParam}"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "GetWithAllParamsRequiredPtr")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "GetWithAllParamsRequiredPtr")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var queryParamRawPtr *string = nil
		queryParamRaw, isqueryParamExists := ctx.GetQuery("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsRequiredPtr", fieldName)
			ctx.Header("x-RunValidatorExtension", "GetWithAllParamsRequiredPtr")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var pathParamRawPtr *string = nil
		pathParamRaw, ispathParamExists := ctx.Params.Get("pathParam")
		if ispathParamExists {
			pathParam := pathParamRaw
			pathParamRawPtr = &pathParam
		}
		if validatorErr := validatorInstance.Var(pathParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "pathParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsRequiredPtr", fieldName)
			ctx.Header("x-RunValidatorExtension", "GetWithAllParamsRequiredPtr")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.GetHeader("headerParam")
		_, isheaderParamExists := ctx.Request.Header[textproto.CanonicalMIMEHeaderKey("headerParam")]
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsRequiredPtr", fieldName)
			ctx.Header("x-RunValidatorExtension", "GetWithAllParamsRequiredPtr")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "GetWithAllParamsRequiredPtr")
		value, opError := controller.GetWithAllParamsRequiredPtr(queryParamRawPtr, pathParamRawPtr, headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "GetWithAllParamsRequiredPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetWithAllParamsRequiredPtr'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/GetWithAllParamsRequiredPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "GetWithAllParamsRequiredPtr")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "GetWithAllParamsRequiredPtr")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "GetWithAllParamsRequiredPtr")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "GetWithAllParamsRequiredPtr")
	})
	engine.POST(toGinUrl("/e2e/post-with-all-params-body"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "PostWithAllParamsWithBody")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "PostWithAllParamsWithBody")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var conversionErr error
		var queryParamRawPtr *string = nil
		queryParamRaw, isqueryParamExists := ctx.GetQuery("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "PostWithAllParamsWithBody", fieldName)
			ctx.Header("x-RunValidatorExtension", "PostWithAllParamsWithBody")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.GetHeader("headerParam")
		_, isheaderParamExists := ctx.Request.Header[textproto.CanonicalMIMEHeaderKey("headerParam")]
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "PostWithAllParamsWithBody", fieldName)
			ctx.Header("x-RunValidatorExtension", "PostWithAllParamsWithBody")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var theBodyRawPtr *Param33theBody.BodyInfo = nil
		conversionErr = bindAndValidateBody(ctx, "application/json", "required", &theBodyRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, conversionErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'PostWithAllParamsWithBody' but body parameter '%s' did not pass validation of '%s' - %s",
					"theBody",
					"BodyInfo",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/gleece/validation/error/PostWithAllParamsWithBody",
			}
			ctx.Header("x-JsonBodyValidationErrorResponseExtension", "PostWithAllParamsWithBody")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "PostWithAllParamsWithBody")
		value, opError := controller.PostWithAllParamsWithBody(*queryParamRawPtr, *headerParamRawPtr, *theBodyRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "PostWithAllParamsWithBody")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBody'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/PostWithAllParamsWithBody",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "PostWithAllParamsWithBody")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "PostWithAllParamsWithBody")
		var outputValidationErr error
		outputValidationErr = validatorInstance.Struct(value)
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBody'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/PostWithAllParamsWithBody",
				Extensions: map[string]string{},
			}
			ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "PostWithAllParamsWithBody")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "PostWithAllParamsWithBody")
	})
	engine.POST(toGinUrl("/e2e/post-with-all-params-body-ptr"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "PostWithAllParamsWithBodyPtr")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "PostWithAllParamsWithBodyPtr")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var conversionErr error
		var queryParamRawPtr *string = nil
		queryParamRaw, isqueryParamExists := ctx.GetQuery("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.GetHeader("headerParam")
		_, isheaderParamExists := ctx.Request.Header[textproto.CanonicalMIMEHeaderKey("headerParam")]
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		var theBodyRawPtr *Param38theBody.BodyInfo = nil
		conversionErr = bindAndValidateBody(ctx, "application/json", "", &theBodyRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, conversionErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'PostWithAllParamsWithBodyPtr' but body parameter '%s' did not pass validation of '%s' - %s",
					"theBody",
					"BodyInfo",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/gleece/validation/error/PostWithAllParamsWithBodyPtr",
			}
			ctx.Header("x-JsonBodyValidationErrorResponseExtension", "PostWithAllParamsWithBodyPtr")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "PostWithAllParamsWithBodyPtr")
		value, opError := controller.PostWithAllParamsWithBodyPtr(queryParamRawPtr, headerParamRawPtr, theBodyRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "PostWithAllParamsWithBodyPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyPtr'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/PostWithAllParamsWithBodyPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "PostWithAllParamsWithBodyPtr")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "PostWithAllParamsWithBodyPtr")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validatorInstance.Struct(value)
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyPtr'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/PostWithAllParamsWithBodyPtr",
				Extensions: map[string]string{},
			}
			ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "PostWithAllParamsWithBodyPtr")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "PostWithAllParamsWithBodyPtr")
	})
	engine.POST(toGinUrl("/e2e/post-with-all-params-body-required-ptr"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "PostWithAllParamsWithBodyRequiredPtr")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "PostWithAllParamsWithBodyRequiredPtr")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var conversionErr error
		var theBodyRawPtr *Param41theBody.BodyInfo = nil
		conversionErr = bindAndValidateBody(ctx, "application/json", "required", &theBodyRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, conversionErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'PostWithAllParamsWithBodyRequiredPtr' but body parameter '%s' did not pass validation of '%s' - %s",
					"theBody",
					"BodyInfo",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/gleece/validation/error/PostWithAllParamsWithBodyRequiredPtr",
			}
			ctx.Header("x-JsonBodyValidationErrorResponseExtension", "PostWithAllParamsWithBodyRequiredPtr")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "PostWithAllParamsWithBodyRequiredPtr")
		value, opError := controller.PostWithAllParamsWithBodyRequiredPtr(theBodyRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "PostWithAllParamsWithBodyRequiredPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyRequiredPtr'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/PostWithAllParamsWithBodyRequiredPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "PostWithAllParamsWithBodyRequiredPtr")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "PostWithAllParamsWithBodyRequiredPtr")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validatorInstance.Struct(value)
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyRequiredPtr'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/PostWithAllParamsWithBodyRequiredPtr",
				Extensions: map[string]string{},
			}
			ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "PostWithAllParamsWithBodyRequiredPtr")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "PostWithAllParamsWithBodyRequiredPtr")
	})
	engine.GET(toGinUrl("/e2e/get-header-start-with-letter"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "GetHeaderStartWithLetter")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "GetHeaderStartWithLetter")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.GetHeader("headerParam")
		_, isheaderParamExists := ctx.Request.Header[textproto.CanonicalMIMEHeaderKey("headerParam")]
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required,validate_starts_with_letter"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "GetHeaderStartWithLetter", fieldName)
			ctx.Header("x-RunValidatorExtension", "GetHeaderStartWithLetter")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "GetHeaderStartWithLetter")
		value, opError := controller.GetHeaderStartWithLetter(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "GetHeaderStartWithLetter")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetHeaderStartWithLetter'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/GetHeaderStartWithLetter",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "GetHeaderStartWithLetter")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "GetHeaderStartWithLetter")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "GetHeaderStartWithLetter")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "GetHeaderStartWithLetter")
	})
	engine.GET(toGinUrl("/e2e/with-default-config-security"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "WithDefaultConfigSecurity")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "WithDefaultConfigSecurity")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.GetHeader("x-test-scopes")
		_, isheaderParamExists := ctx.Request.Header[textproto.CanonicalMIMEHeaderKey("x-test-scopes")]
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithDefaultConfigSecurity", fieldName)
			ctx.Header("x-RunValidatorExtension", "WithDefaultConfigSecurity")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "WithDefaultConfigSecurity")
		value, opError := controller.WithDefaultConfigSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "WithDefaultConfigSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithDefaultConfigSecurity'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/WithDefaultConfigSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "WithDefaultConfigSecurity")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "WithDefaultConfigSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "WithDefaultConfigSecurity")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "WithDefaultConfigSecurity")
	})
	engine.GET(toGinUrl("/e2e/with-one-security"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "WithOneSecurity")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"other",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "WithOneSecurity")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.GetHeader("x-test-scopes")
		_, isheaderParamExists := ctx.Request.Header[textproto.CanonicalMIMEHeaderKey("x-test-scopes")]
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithOneSecurity", fieldName)
			ctx.Header("x-RunValidatorExtension", "WithOneSecurity")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "WithOneSecurity")
		value, opError := controller.WithOneSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "WithOneSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithOneSecurity'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/WithOneSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "WithOneSecurity")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "WithOneSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "WithOneSecurity")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "WithOneSecurity")
	})
	engine.GET(toGinUrl("/e2e/with-two-security"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "WithTwoSecurity")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"other",
							},
						},
					},
				},
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"write",
								"read",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "WithTwoSecurity")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.GetHeader("x-test-scopes")
		_, isheaderParamExists := ctx.Request.Header[textproto.CanonicalMIMEHeaderKey("x-test-scopes")]
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithTwoSecurity", fieldName)
			ctx.Header("x-RunValidatorExtension", "WithTwoSecurity")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "WithTwoSecurity")
		value, opError := controller.WithTwoSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "WithTwoSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithTwoSecurity'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/WithTwoSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "WithTwoSecurity")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "WithTwoSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "WithTwoSecurity")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "WithTwoSecurity")
	})
	engine.GET(toGinUrl("/e2e/with-two-security-same-method"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "WithTwoSecuritySameMethod")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"other",
							},
						},
					},
				},
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"write",
								"read",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "WithTwoSecuritySameMethod")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.GetHeader("x-test-scopes")
		_, isheaderParamExists := ctx.Request.Header[textproto.CanonicalMIMEHeaderKey("x-test-scopes")]
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithTwoSecuritySameMethod", fieldName)
			ctx.Header("x-RunValidatorExtension", "WithTwoSecuritySameMethod")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "WithTwoSecuritySameMethod")
		value, opError := controller.WithTwoSecuritySameMethod(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "WithTwoSecuritySameMethod")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithTwoSecuritySameMethod'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/WithTwoSecuritySameMethod",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "WithTwoSecuritySameMethod")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "WithTwoSecuritySameMethod")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "WithTwoSecuritySameMethod")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "WithTwoSecuritySameMethod")
	})
	engine.GET(toGinUrl("/e2e/default-error"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "DefaultError")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "DefaultError")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "DefaultError")
		opError := controller.DefaultError()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "DefaultError")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'DefaultError'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/DefaultError",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "DefaultError")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "DefaultError")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "DefaultError")
		ctx.Status(statusCode)
		ctx.Header("x-RouteEndRoutesExtension", "DefaultError")
	})
	engine.GET(toGinUrl("/e2e/default-error-with-payload"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "DefaultErrorWithPayload")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "DefaultErrorWithPayload")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "DefaultErrorWithPayload")
		value, opError := controller.DefaultErrorWithPayload()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "DefaultErrorWithPayload")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'DefaultErrorWithPayload'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/DefaultErrorWithPayload",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "DefaultErrorWithPayload")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "DefaultErrorWithPayload")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "DefaultErrorWithPayload")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "DefaultErrorWithPayload")
	})
	engine.GET(toGinUrl("/e2e/custom-error"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "CustomError")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "CustomError")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "CustomError")
		opError := controller.CustomError()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "CustomError")
		statusCode := getStatusCode(&controller, false, opError)
		emptyErr := Response62CustomError.CustomError{}
		if opError != emptyErr {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			ctx.JSON(statusCode, opError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "CustomError")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "CustomError")
		ctx.Status(statusCode)
		ctx.Header("x-RouteEndRoutesExtension", "CustomError")
	})
	engine.GET(toGinUrl("/e2e/custom-error-ptr"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "CustomPtrError")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "CustomPtrError")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "CustomPtrError")
		opError := controller.CustomPtrError()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "CustomPtrError")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			ctx.JSON(statusCode, opError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "CustomPtrError")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "CustomPtrError")
		ctx.Status(statusCode)
		ctx.Header("x-RouteEndRoutesExtension", "CustomPtrError")
	})
	engine.GET(toGinUrl("/e2e/503-error-code"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "Error503")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "Error503")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "Error503")
		opError := controller.Error503()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "Error503")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Error503'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/Error503",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "Error503")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "Error503")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "Error503")
		ctx.Status(statusCode)
		ctx.Header("x-RouteEndRoutesExtension", "Error503")
	})
	engine.GET(toGinUrl("/e2e/custom-error-503"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "CustomError503")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "CustomError503")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "CustomError503")
		opError := controller.CustomError503()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "CustomError503")
		statusCode := getStatusCode(&controller, false, opError)
		emptyErr := Response65CustomError.CustomError{}
		if opError != emptyErr {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			ctx.JSON(statusCode, opError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "CustomError503")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "CustomError503")
		ctx.Status(statusCode)
		ctx.Header("x-RouteEndRoutesExtension", "CustomError503")
	})
	engine.GET(toGinUrl("/e2e/context-access"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "ContextAccess")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "ContextAccess")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "ContextAccess")
		opError := controller.ContextAccess()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "ContextAccess")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ContextAccess'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/ContextAccess",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "ContextAccess")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "ContextAccess")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "ContextAccess")
		ctx.Status(statusCode)
		ctx.Header("x-RouteEndRoutesExtension", "ContextAccess")
	})
	engine.GET(toGinUrl("/e2e/http-method"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "Get")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "Get")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "Get")
		opError := controller.Get()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "Get")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Get'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/Get",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "Get")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "Get")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "Get")
		ctx.Status(statusCode)
		ctx.Header("x-RouteEndRoutesExtension", "Get")
	})
	engine.POST(toGinUrl("/e2e/http-method"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "Post")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "Post")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "Post")
		opError := controller.Post()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "Post")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Post'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/Post",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "Post")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "Post")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "Post")
		ctx.Status(statusCode)
		ctx.Header("x-RouteEndRoutesExtension", "Post")
	})
	engine.PUT(toGinUrl("/e2e/http-method"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "Put")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "Put")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "Put")
		opError := controller.Put()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "Put")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Put'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/Put",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "Put")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "Put")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "Put")
		ctx.Status(statusCode)
		ctx.Header("x-RouteEndRoutesExtension", "Put")
	})
	engine.DELETE(toGinUrl("/e2e/http-method"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "Delete")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "Delete")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "Delete")
		opError := controller.Delete()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "Delete")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Delete'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/Delete",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "Delete")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "Delete")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "Delete")
		ctx.Status(statusCode)
		ctx.Header("x-RouteEndRoutesExtension", "Delete")
	})
	engine.PATCH(toGinUrl("/e2e/http-method"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "Patch")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "Patch")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "Patch")
		opError := controller.Patch()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "Patch")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Patch'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/Patch",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "Patch")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "Patch")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "Patch")
		ctx.Status(statusCode)
		ctx.Header("x-RouteEndRoutesExtension", "Patch")
	})
	engine.GET(toGinUrl("/e2e/template-context-1"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "TemplateContext1")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "TemplateContext1")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "TemplateContext1")
		value, opError := controller.TemplateContext1()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "TemplateContext1")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TemplateContext1'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TemplateContext1",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "TemplateContext1")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "TemplateContext1")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "TemplateContext1")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "TemplateContext1")
		ctx.Header("x-level", "high")
	})
	engine.GET(toGinUrl("/e2e/template-context-2"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "TemplateContext2")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "TemplateContext2")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "TemplateContext2")
		value, opError := controller.TemplateContext2()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "TemplateContext2")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TemplateContext2'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TemplateContext2",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "TemplateContext2")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "TemplateContext2")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "TemplateContext2")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "TemplateContext2")
		ctx.Header("x-mode", "100")
		ctx.Header("x-level", "low")
	})
	engine.POST(toGinUrl("/e2e/form"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "TestForm")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "TestForm")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var item1RawPtr *string = nil
		item1Raw, isitem1Exists := ctx.GetPostForm("item1")
		if isitem1Exists {
			item1 := item1Raw
			item1RawPtr = &item1
		}
		if validatorErr := validatorInstance.Var(item1RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "item1"
			validationError := wrapValidatorError(validatorErr, "TestForm", fieldName)
			ctx.Header("x-RunValidatorExtension", "TestForm")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		var item2RawPtr *string = nil
		item2Raw, isitem2Exists := ctx.GetPostForm("item2")
		if isitem2Exists {
			item2 := item2Raw
			item2RawPtr = &item2
		}
		if validatorErr := validatorInstance.Var(item2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "item2"
			validationError := wrapValidatorError(validatorErr, "TestForm", fieldName)
			ctx.Header("x-RunValidatorExtension", "TestForm")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "TestForm")
		value, opError := controller.TestForm(*item1RawPtr, *item2RawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "TestForm")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestForm'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TestForm",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "TestForm")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "TestForm")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "TestForm")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "TestForm")
	})
	engine.POST(toGinUrl("/e2e/test-response-validation"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "TestResponseValidation")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "TestResponseValidation")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "TestResponseValidation")
		value, opError := controller.TestResponseValidation()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "TestResponseValidation")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidation'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TestResponseValidation",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "TestResponseValidation")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "TestResponseValidation")
		var outputValidationErr error
		outputValidationErr = validatorInstance.Struct(value)
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidation'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/TestResponseValidation",
				Extensions: map[string]string{},
			}
			ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "TestResponseValidation")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "TestResponseValidation")
	})
	engine.POST(toGinUrl("/e2e/test-response-validation-ptr"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "TestResponseValidationPtr")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "TestResponseValidationPtr")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "TestResponseValidationPtr")
		value, opError := controller.TestResponseValidationPtr()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "TestResponseValidationPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationPtr'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TestResponseValidationPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "TestResponseValidationPtr")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "TestResponseValidationPtr")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validatorInstance.Struct(value)
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationPtr'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/TestResponseValidationPtr",
				Extensions: map[string]string{},
			}
			ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "TestResponseValidationPtr")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "TestResponseValidationPtr")
	})
	engine.POST(toGinUrl("/e2e/test-response-validation-null"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "TestResponseValidationNull")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "TestResponseValidationNull")
			return
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "TestResponseValidationNull")
		value, opError := controller.TestResponseValidationNull()
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "TestResponseValidationNull")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationNull'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TestResponseValidationNull",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "TestResponseValidationNull")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "TestResponseValidationNull")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validatorInstance.Struct(value)
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationNull'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/TestResponseValidationNull",
				Extensions: map[string]string{},
			}
			ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "TestResponseValidationNull")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "TestResponseValidationNull")
	})
	// E2EClassSecController
	engine.GET(toGinUrl("/e2e/with-default-class-security"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "WithDefaultClassSecurity")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"class",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "WithDefaultClassSecurity")
			return
		}
		controller := E2EClassSecControllerImport.E2EClassSecController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.GetHeader("x-test-scopes")
		_, isheaderParamExists := ctx.Request.Header[textproto.CanonicalMIMEHeaderKey("x-test-scopes")]
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithDefaultClassSecurity", fieldName)
			ctx.Header("x-RunValidatorExtension", "WithDefaultClassSecurity")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "WithDefaultClassSecurity")
		value, opError := controller.WithDefaultClassSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "WithDefaultClassSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithDefaultClassSecurity'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/WithDefaultClassSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "WithDefaultClassSecurity")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "WithDefaultClassSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "WithDefaultClassSecurity")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "WithDefaultClassSecurity")
	})
	engine.GET(toGinUrl("/e2e/with-default-override-class-security"), func(ctx *gin.Context) {
		ctx.Header("x-RouteStartRoutesExtension", "WithOverrideClassSecurity")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"method",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(ctx, authErr, "WithOverrideClassSecurity")
			return
		}
		controller := E2EClassSecControllerImport.E2EClassSecController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.GetHeader("x-test-scopes")
		_, isheaderParamExists := ctx.Request.Header[textproto.CanonicalMIMEHeaderKey("x-test-scopes")]
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithOverrideClassSecurity", fieldName)
			ctx.Header("x-RunValidatorExtension", "WithOverrideClassSecurity")
			ctx.JSON(http.StatusUnprocessableEntity, validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Header("x-BeforeOperationRoutesExtension", "WithOverrideClassSecurity")
		value, opError := controller.WithOverrideClassSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Header(key, value)
		}
		ctx.Header("x-inject", "true")
		ctx.Header("x-ResponseHeadersExtension", "WithOverrideClassSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithOverrideClassSecurity'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/WithOverrideClassSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Header("x-JsonErrorResponseExtension", "WithOverrideClassSecurity")
			ctx.JSON(statusCode, stdError)
			return
		}
		ctx.Header("x-JsonResponseExtension", "WithOverrideClassSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Header("x-AfterOperationRoutesExtension", "WithOverrideClassSecurity")
		ctx.JSON(statusCode, value)
		ctx.Header("x-RouteEndRoutesExtension", "WithOverrideClassSecurity")
	})
}
