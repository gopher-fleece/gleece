/*
--
This file is automatically generated. Any manual changes to this file may be overwritten.
It includes routes and handlers by the Gleece API Routes Generator.
--
Authors: Haim Kastner & Yuval Pomerchik
Generated by: Gleece Routes Generator
Generated Date: 2025-03-29
Target Engine: Echo v4 (https://github.com/labstack/echo)
--
Usage:
Refer to the Gleece documentation for details on how to use the generated routes and handlers.
--
Repository: https://github.com/gopher-fleece/gleece
--
*/
package routes
import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"github.com/go-playground/validator/v10"
	E2EControllerImport "github.com/gopher-fleece/gleece/e2e/assets"
	RequestAuth "github.com/gopher-fleece/gleece/e2e/echo/auth"
	"github.com/gopher-fleece/runtime"
	"github.com/labstack/echo/v4"
	Param41theBody "github.com/gopher-fleece/gleece/e2e/assets"
	Param46theBody "github.com/gopher-fleece/gleece/e2e/assets"
	Param49theBody "github.com/gopher-fleece/gleece/e2e/assets"
	Response70CustomError "github.com/gopher-fleece/gleece/e2e/assets"
	Response73CustomError "github.com/gopher-fleece/gleece/e2e/assets"
	Param100value1 "github.com/gopher-fleece/gleece/e2e/assets"
	Param101value2 "github.com/gopher-fleece/gleece/e2e/assets"
	Param102value3 "github.com/gopher-fleece/gleece/e2e/assets"
	Param105value1 "github.com/gopher-fleece/gleece/e2e/assets"
	Param106value2 "github.com/gopher-fleece/gleece/e2e/assets"
	Param107value3 "github.com/gopher-fleece/gleece/e2e/assets"
	Param110value1 "github.com/gopher-fleece/gleece/e2e/assets"
	Param113unit "github.com/haimkastner/unitsnet-go/units"
	Param114data "github.com/haimkastner/unitsnet-go/units"
	Param118data "github.com/gopher-fleece/gleece/e2e/assets"
	Param117unit "github.com/haimkastner/unitsnet-go/units"
	Param121data "github.com/haimkastner/unitsnet-go/units"
	Param124data "github.com/gopher-fleece/gleece/e2e/assets"
	Param127data "github.com/gopher-fleece/gleece/e2e/assets"
	Param130data "github.com/gopher-fleece/gleece/e2e/assets"
	E2EClassSecControllerImport "github.com/gopher-fleece/gleece/e2e/assets"
	// ImportsExtension - test
)
var validatorInstance = validator.New()
var urlParamRegex *regexp.Regexp
type SecurityListRelation string
const (
	SecurityListRelationAnd SecurityListRelation = "AND"
)
type SecurityCheckList struct {
	Checks   []runtime.SecurityCheck
	Relation SecurityListRelation
}
// TypeDeclarationsExtension - test
func registerEnumValidation(validate *validator.Validate, validationName string, allowedValues []string) {
	// Convert the array to a map for O(1) lookup
	lookup := make(map[string]struct{})
	for _, val := range allowedValues {
		lookup[val] = struct{}{}
	}
	// Register the custom validation
	validate.RegisterValidation(validationName, func(fl validator.FieldLevel) bool {
		field := fl.Field().String()
		_, exists := lookup[field]
		return exists
	})
}
func extractValidationErrorMessage(err error, fieldName *string) string {
	if err == nil {
		return ""
	}
	validationErrors, ok := err.(validator.ValidationErrors)
	if !ok {
		return err.Error()
	}
	var errStr string
	for _, validationErr := range validationErrors {
		fName := validationErr.Field()
		if fieldName != nil {
			fName = *fieldName
		}
		errStr += fmt.Sprintf("Field '%s' failed validation with tag '%s'. ", fName, validationErr.Tag())
	}
	return errStr
}
func getStatusCode(controller runtime.Controller, hasReturnValue bool, err error) int {
	if controller.GetStatus() != nil {
		return int(*controller.GetStatus())
	}
	if err != nil {
		return http.StatusInternalServerError
	}
	if hasReturnValue {
		return http.StatusOK
	}
	return http.StatusNoContent
}
func bindAndValidateBody[TOutput any](ctx echo.Context, contentType string, validation string, output **TOutput) error {
	var err error
	bodyBytes, err := io.ReadAll(ctx.Request().Body)
	if err != nil || len(bodyBytes) == 0 {
		if strings.Contains(validation, "required") {
			return fmt.Errorf("body is required but was not provided")
		}
		return nil
	}
	var deserializedOutput TOutput
	switch contentType {
	case "application/json":
		err = json.Unmarshal(bodyBytes, &deserializedOutput)
	default:
		return fmt.Errorf("content-type %s is not currently supported by the validation subsystem", contentType)
	}
	if err != nil {
		return err
	}
	// Validate the unmarshaled data recursively
	if err = validateDataRecursive(deserializedOutput, ""); err != nil {
		return err
	}
	*output = &deserializedOutput
	return nil
}
func validateDataRecursive(data interface{}, path string) error {
	val := reflect.ValueOf(data)
	// Handle pointers by dereferencing
	if val.Kind() == reflect.Ptr {
		if val.IsNil() {
			return nil
		}
		return validateDataRecursive(val.Elem().Interface(), path)
	}
	// Handle different types
	switch val.Kind() {
	case reflect.Slice, reflect.Array:
		// For slices/arrays, validate each element recursively
		for i := 0; i < val.Len(); i++ {
			elemPath := path
			if path != "" {
				elemPath = fmt.Sprintf("%s[%d]", path, i)
			} else {
				elemPath = fmt.Sprintf("[%d]", i)
			}
			// Get the element - handle case where element might be nil
			elem := val.Index(i)
			if elem.Kind() == reflect.Ptr && elem.IsNil() {
				continue
			}
			// Validate the element recursively
			if err := validateDataRecursive(elem.Interface(), elemPath); err != nil {
				return err
			}
		}
		return nil
	case reflect.Map:
		// For maps, validate each value recursively
		for _, key := range val.MapKeys() {
			elemPath := path
			if path != "" {
				elemPath = fmt.Sprintf("%s.%v", path, key.Interface())
			} else {
				elemPath = fmt.Sprintf("%v", key.Interface())
			}
			elemVal := val.MapIndex(key)
			if elemVal.Kind() == reflect.Ptr && elemVal.IsNil() {
				continue
			}
			if err := validateDataRecursive(elemVal.Interface(), elemPath); err != nil {
				return err
			}
		}
		return nil
	case reflect.Struct:
		// Validate structs with the validator
		if err := validatorInstance.Struct(data); err != nil {
			if path != "" {
				return fmt.Errorf("validation error at %s: %w", path, err)
			}
			return err
		}
		return nil
	default:
		// Primitive types don't need validation
		return nil
	}
}
func toEchoUrl(url string) string {
	processedUrl := urlParamRegex.ReplaceAllString(url, ":$1")
	processedUrl = strings.ReplaceAll(processedUrl, "//", "/")
	if processedUrl == "" {
		return "/"
	}
	if !strings.HasPrefix(processedUrl, "/") {
		processedUrl = "/" + processedUrl
	}
	return processedUrl
}
func authorize(ctx echo.Context, checksLists []SecurityCheckList) *runtime.SecurityError {
	var lastError *runtime.SecurityError
	for _, list := range checksLists {
		if list.Relation != SecurityListRelationAnd {
			panic(
				"Encountered a security list relation of type '%s' - this is unexpected and indicates a bug in Gleece itself." +
					"Please open an issue at https://github.com/gopher-fleece/gleece/issues",
			)
		}
		// Iterate over each security list
		encounteredErrorInList := false
		for _, check := range list.Checks {
			secErr := RequestAuth.GleeceRequestAuthorization(ctx, check)
			if secErr != nil {
				lastError = secErr
				encounteredErrorInList = true
				break
			}
		}
		// If no error was encountered, validation is considered successful
		// otherwise, we continue over to the next iteration whilst keeping track of the last error
		if !encounteredErrorInList {
			return nil
		}
	}
	// If we got here it means authentication has failed
	return lastError
}
func handleAuthorizationError(ctx echo.Context, authErr *runtime.SecurityError, operationId string) error {
	statusCode := int(authErr.StatusCode)
	if authErr.CustomError != nil {
		// For now, we support JSON only
		return ctx.JSON(statusCode, authErr.CustomError.Payload)
	}
	stdError := runtime.Rfc7807Error{
		Type:     http.StatusText(statusCode),
		Detail:   authErr.Message,
		Status:   statusCode,
		Instance: "/gleece/authorization/error/" + operationId,
	}
	return ctx.JSON(statusCode, stdError)
}
func wrapValidatorError(validatorErr error, operationId string, fieldName string) runtime.Rfc7807Error {
	return runtime.Rfc7807Error{
		Type: http.StatusText(http.StatusUnprocessableEntity),
		Detail: fmt.Sprintf(
			"A request was made to operation '%s' but parameter '%s' did not pass validation - %s",
			operationId,
			fieldName,
			extractValidationErrorMessage(validatorErr, &fieldName),
		),
		Status:   http.StatusUnprocessableEntity,
		Instance: fmt.Sprintf("/gleece/validation/error/%s", operationId),
	}
}
// FunctionDeclarationsExtension - test
type MiddlewareFunc func(ctx echo.Context) bool
type ErrorMiddlewareFunc func(ctx echo.Context, err error) bool
var beforeOperationMiddlewares []MiddlewareFunc
var afterOperationSuccessMiddlewares []MiddlewareFunc
var onErrorMiddlewares []ErrorMiddlewareFunc
var onInputValidationMiddlewares []ErrorMiddlewareFunc
var onOutputValidationMiddlewares []ErrorMiddlewareFunc
func RegisterMiddleware(executionType runtime.MiddlewareExecutionType, middlewareFunc MiddlewareFunc) {
	switch executionType {
	case runtime.BeforeOperation:
		beforeOperationMiddlewares = append(beforeOperationMiddlewares, middlewareFunc)
	case runtime.AfterOperationSuccess:
		afterOperationSuccessMiddlewares = append(afterOperationSuccessMiddlewares, middlewareFunc)
	}
}
func RegisterErrorMiddleware(executionType runtime.ErrorMiddlewareExecutionType, errorMiddlewareFunc ErrorMiddlewareFunc) {
	switch executionType {
	case runtime.OnInputValidationError:
		onInputValidationMiddlewares = append(onInputValidationMiddlewares, errorMiddlewareFunc)
	case runtime.OnOutputValidationError:
		onOutputValidationMiddlewares = append(onOutputValidationMiddlewares, errorMiddlewareFunc)
	case runtime.OnOperationError:
		onErrorMiddlewares = append(onErrorMiddlewares, errorMiddlewareFunc)
	}
}
func RegisterCustomValidator(validateTagName string, validateFunc runtime.ValidationFunc) {
	validatorInstance.RegisterValidation(validateTagName, func(fl validator.FieldLevel) bool {
		return validateFunc(fl)
	})
}
func RegisterRoutes(engine *echo.Echo) {
	urlParamRegex = regexp.MustCompile(`\{([\w\d-_]+)\}`)
	registerEnumValidation(validatorInstance, "status_enumeration_enum", []string{"active", "inactive"})
	registerEnumValidation(validatorInstance, "length_units_enum", []string{"Angstrom", "AstronomicalUnit", "Centimeter", "Chain", "DataMile", "Decameter", "Decimeter", "DtpPica", "DtpPoint", "Fathom", "Femtometer", "Foot", "Gigameter", "Hand", "Hectometer", "Inch", "Kilofoot", "KilolightYear", "Kilometer", "Kiloparsec", "Kiloyard", "LightYear", "MegalightYear", "Megameter", "Megaparsec", "Meter", "Microinch", "Micrometer", "Mil", "Mile", "Millimeter", "Nanometer", "NauticalMile", "Parsec", "Picometer", "PrinterPica", "PrinterPoint", "Shackle", "SolarRadius", "Twip", "UsSurveyFoot", "Yard"})
	registerEnumValidation(validatorInstance, "number_enumeration_enum", []string{"1", "2"})
	// RegisterRoutesExtension - test
	// E2EController
	engine.GET(toEchoUrl("/e2e/simple-get"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "SimpleGet")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "SimpleGet")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "SimpleGet")
		value, opError := controller.SimpleGet()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "SimpleGet")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGet'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGet",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "SimpleGet")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "SimpleGet")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "SimpleGet")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "SimpleGet")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/simple-get-empty-string"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "SimpleGetEmptyString")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "SimpleGetEmptyString")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetEmptyString")
		value, opError := controller.SimpleGetEmptyString()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "SimpleGetEmptyString")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetEmptyString'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetEmptyString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "SimpleGetEmptyString")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "SimpleGetEmptyString")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "SimpleGetEmptyString")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "SimpleGetEmptyString")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/simple-get-ptr-string"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "SimpleGetPtrString")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "SimpleGetPtrString")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetPtrString")
		value, opError := controller.SimpleGetPtrString()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "SimpleGetPtrString")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetPtrString'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetPtrString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "SimpleGetPtrString")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "SimpleGetPtrString")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "SimpleGetPtrString")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "SimpleGetPtrString")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/simple-get-null-string"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "SimpleGetNullString")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "SimpleGetNullString")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetNullString")
		value, opError := controller.SimpleGetNullString()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "SimpleGetNullString")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetNullString'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetNullString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "SimpleGetNullString")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "SimpleGetNullString")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "SimpleGetNullString")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "SimpleGetNullString")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/simple-get-object"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "SimpleGetObject")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "SimpleGetObject")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetObject")
		value, opError := controller.SimpleGetObject()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "SimpleGetObject")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObject'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetObject",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "SimpleGetObject")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "SimpleGetObject")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObject'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/SimpleGetObject",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "SimpleGetObject")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "SimpleGetObject")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/simple-get-object-ptr"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "SimpleGetObjectPtr")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "SimpleGetObjectPtr")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetObjectPtr")
		value, opError := controller.SimpleGetObjectPtr()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "SimpleGetObjectPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectPtr'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetObjectPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "SimpleGetObjectPtr")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "SimpleGetObjectPtr")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectPtr'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/SimpleGetObjectPtr",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "SimpleGetObjectPtr")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "SimpleGetObjectPtr")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/simple-get-object-null"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "SimpleGetObjectNull")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "SimpleGetObjectNull")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetObjectNull")
		value, opError := controller.SimpleGetObjectNull()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "SimpleGetObjectNull")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectNull'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetObjectNull",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "SimpleGetObjectNull")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "SimpleGetObjectNull")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectNull'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/SimpleGetObjectNull",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "SimpleGetObjectNull")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "SimpleGetObjectNull")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/primitive-return-type"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "PrimitiveReturnType")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "PrimitiveReturnType")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "PrimitiveReturnType")
		value, opError := controller.PrimitiveReturnType()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "PrimitiveReturnType")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PrimitiveReturnType'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/PrimitiveReturnType",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "PrimitiveReturnType")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "PrimitiveReturnType")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "PrimitiveReturnType")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "PrimitiveReturnType")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/primitive-array-return-type"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "PrimitiveArrayReturnType")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "PrimitiveArrayReturnType")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "PrimitiveArrayReturnType")
		value, opError := controller.PrimitiveArrayReturnType()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "PrimitiveArrayReturnType")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PrimitiveArrayReturnType'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/PrimitiveArrayReturnType",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "PrimitiveArrayReturnType")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "PrimitiveArrayReturnType")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "PrimitiveArrayReturnType")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "PrimitiveArrayReturnType")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/primitive-alias-return-type"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "PrimitiveAliasReturnType")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "PrimitiveAliasReturnType")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "PrimitiveAliasReturnType")
		value, opError := controller.PrimitiveAliasReturnType()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "PrimitiveAliasReturnType")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PrimitiveAliasReturnType'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/PrimitiveAliasReturnType",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "PrimitiveAliasReturnType")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "PrimitiveAliasReturnType")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'PrimitiveAliasReturnType'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/PrimitiveAliasReturnType",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "PrimitiveAliasReturnType")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "PrimitiveAliasReturnType")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/primitive-alias-array-return-type"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "PrimitiveAliasArrayReturnType")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "PrimitiveAliasArrayReturnType")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "PrimitiveAliasArrayReturnType")
		value, opError := controller.PrimitiveAliasArrayReturnType()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "PrimitiveAliasArrayReturnType")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PrimitiveAliasArrayReturnType'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/PrimitiveAliasArrayReturnType",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "PrimitiveAliasArrayReturnType")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "PrimitiveAliasArrayReturnType")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'PrimitiveAliasArrayReturnType'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/PrimitiveAliasArrayReturnType",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "PrimitiveAliasArrayReturnType")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "PrimitiveAliasArrayReturnType")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/simple-get-empty"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "SimpleGetEmpty")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "SimpleGetEmpty")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var queryParamRawPtr *string = nil
		queryParamRaw := ctx.QueryParam("queryParam")
		isqueryParamExists := ctx.Request().URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "SimpleGetEmpty", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "SimpleGetEmpty")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetEmpty")
		opError := controller.SimpleGetEmpty(*queryParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "SimpleGetEmpty")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetEmpty'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/SimpleGetEmpty",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "SimpleGetEmpty")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "SimpleGetEmpty")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "SimpleGetEmpty")
		ctx.Response().WriteHeader(statusCode)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "SimpleGetEmpty")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/get-with-all-params/{pathParam}"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "GetWithAllParams")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "GetWithAllParams")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var queryParamRawPtr *string = nil
		queryParamRaw := ctx.QueryParam("queryParam")
		isqueryParamExists := ctx.Request().URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParams", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "GetWithAllParams")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		var pathParamRawPtr *string = nil
		pathParamRaw := ctx.Param("pathParam")
		ispathParamExists := true // if parameter is in route but not provided, it won't reach this handler
		if ispathParamExists {
			pathParam := pathParamRaw
			pathParamRawPtr = &pathParam
		}
		if validatorErr := validatorInstance.Var(pathParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "pathParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParams", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "GetWithAllParams")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.Request().Header.Get("headerParam")
		_, isheaderParamExists := ctx.Request().Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParams", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "GetWithAllParams")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "GetWithAllParams")
		value, opError := controller.GetWithAllParams(*queryParamRawPtr, *pathParamRawPtr, *headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "GetWithAllParams")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetWithAllParams'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/GetWithAllParams",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "GetWithAllParams")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "GetWithAllParams")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "GetWithAllParams")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "GetWithAllParams")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/get-with-all-params-ptr/{pathParam}"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "GetWithAllParamsPtr")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "GetWithAllParamsPtr")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var queryParamRawPtr *string = nil
		queryParamRaw := ctx.QueryParam("queryParam")
		isqueryParamExists := ctx.Request().URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		var pathParamRawPtr *string = nil
		pathParamRaw := ctx.Param("pathParam")
		ispathParamExists := true // if parameter is in route but not provided, it won't reach this handler
		if ispathParamExists {
			pathParam := pathParamRaw
			pathParamRawPtr = &pathParam
		}
		if validatorErr := validatorInstance.Var(pathParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "pathParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsPtr", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "GetWithAllParamsPtr")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.Request().Header.Get("headerParam")
		_, isheaderParamExists := ctx.Request().Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "GetWithAllParamsPtr")
		value, opError := controller.GetWithAllParamsPtr(queryParamRawPtr, pathParamRawPtr, headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "GetWithAllParamsPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetWithAllParamsPtr'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/GetWithAllParamsPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "GetWithAllParamsPtr")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "GetWithAllParamsPtr")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "GetWithAllParamsPtr")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "GetWithAllParamsPtr")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/get-with-all-params-required-ptr/{pathParam}"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "GetWithAllParamsRequiredPtr")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "GetWithAllParamsRequiredPtr")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var queryParamRawPtr *string = nil
		queryParamRaw := ctx.QueryParam("queryParam")
		isqueryParamExists := ctx.Request().URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsRequiredPtr", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "GetWithAllParamsRequiredPtr")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		var pathParamRawPtr *string = nil
		pathParamRaw := ctx.Param("pathParam")
		ispathParamExists := true // if parameter is in route but not provided, it won't reach this handler
		if ispathParamExists {
			pathParam := pathParamRaw
			pathParamRawPtr = &pathParam
		}
		if validatorErr := validatorInstance.Var(pathParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "pathParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsRequiredPtr", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "GetWithAllParamsRequiredPtr")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.Request().Header.Get("headerParam")
		_, isheaderParamExists := ctx.Request().Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsRequiredPtr", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "GetWithAllParamsRequiredPtr")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "GetWithAllParamsRequiredPtr")
		value, opError := controller.GetWithAllParamsRequiredPtr(queryParamRawPtr, pathParamRawPtr, headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "GetWithAllParamsRequiredPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetWithAllParamsRequiredPtr'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/GetWithAllParamsRequiredPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "GetWithAllParamsRequiredPtr")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "GetWithAllParamsRequiredPtr")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "GetWithAllParamsRequiredPtr")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "GetWithAllParamsRequiredPtr")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/post-with-all-params-body"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "PostWithAllParamsWithBody")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "PostWithAllParamsWithBody")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var conversionErr error
		var queryParamRawPtr *string = nil
		queryParamRaw := ctx.QueryParam("queryParam")
		isqueryParamExists := ctx.Request().URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "PostWithAllParamsWithBody", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "PostWithAllParamsWithBody")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.Request().Header.Get("headerParam")
		_, isheaderParamExists := ctx.Request().Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "PostWithAllParamsWithBody", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "PostWithAllParamsWithBody")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		var theBodyRawPtr *Param41theBody.BodyInfo = nil
		conversionErr = bindAndValidateBody(ctx, "application/json", "required", &theBodyRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, conversionErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'PostWithAllParamsWithBody' but body parameter '%s' did not pass validation of '%s' - %s",
					"theBody",
					"BodyInfo",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/gleece/validation/error/PostWithAllParamsWithBody",
			}
			ctx.Response().Header().Set("x-JsonBodyValidationErrorResponseExtension", "PostWithAllParamsWithBody")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "PostWithAllParamsWithBody")
		value, opError := controller.PostWithAllParamsWithBody(*queryParamRawPtr, *headerParamRawPtr, *theBodyRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "PostWithAllParamsWithBody")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBody'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/PostWithAllParamsWithBody",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "PostWithAllParamsWithBody")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "PostWithAllParamsWithBody")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBody'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/PostWithAllParamsWithBody",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "PostWithAllParamsWithBody")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "PostWithAllParamsWithBody")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/post-with-all-params-body-ptr"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "PostWithAllParamsWithBodyPtr")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "PostWithAllParamsWithBodyPtr")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var conversionErr error
		var queryParamRawPtr *string = nil
		queryParamRaw := ctx.QueryParam("queryParam")
		isqueryParamExists := ctx.Request().URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.Request().Header.Get("headerParam")
		_, isheaderParamExists := ctx.Request().Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		var theBodyRawPtr *Param46theBody.BodyInfo = nil
		conversionErr = bindAndValidateBody(ctx, "application/json", "", &theBodyRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, conversionErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'PostWithAllParamsWithBodyPtr' but body parameter '%s' did not pass validation of '%s' - %s",
					"theBody",
					"BodyInfo",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/gleece/validation/error/PostWithAllParamsWithBodyPtr",
			}
			ctx.Response().Header().Set("x-JsonBodyValidationErrorResponseExtension", "PostWithAllParamsWithBodyPtr")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "PostWithAllParamsWithBodyPtr")
		value, opError := controller.PostWithAllParamsWithBodyPtr(queryParamRawPtr, headerParamRawPtr, theBodyRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "PostWithAllParamsWithBodyPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyPtr'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/PostWithAllParamsWithBodyPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "PostWithAllParamsWithBodyPtr")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "PostWithAllParamsWithBodyPtr")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyPtr'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/PostWithAllParamsWithBodyPtr",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "PostWithAllParamsWithBodyPtr")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "PostWithAllParamsWithBodyPtr")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/post-with-all-params-body-required-ptr"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "PostWithAllParamsWithBodyRequiredPtr")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "PostWithAllParamsWithBodyRequiredPtr")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var conversionErr error
		var theBodyRawPtr *Param49theBody.BodyInfo = nil
		conversionErr = bindAndValidateBody(ctx, "application/json", "required", &theBodyRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, conversionErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'PostWithAllParamsWithBodyRequiredPtr' but body parameter '%s' did not pass validation of '%s' - %s",
					"theBody",
					"BodyInfo",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/gleece/validation/error/PostWithAllParamsWithBodyRequiredPtr",
			}
			ctx.Response().Header().Set("x-JsonBodyValidationErrorResponseExtension", "PostWithAllParamsWithBodyRequiredPtr")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "PostWithAllParamsWithBodyRequiredPtr")
		value, opError := controller.PostWithAllParamsWithBodyRequiredPtr(theBodyRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "PostWithAllParamsWithBodyRequiredPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyRequiredPtr'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/PostWithAllParamsWithBodyRequiredPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "PostWithAllParamsWithBodyRequiredPtr")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "PostWithAllParamsWithBodyRequiredPtr")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyRequiredPtr'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/PostWithAllParamsWithBodyRequiredPtr",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "PostWithAllParamsWithBodyRequiredPtr")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "PostWithAllParamsWithBodyRequiredPtr")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/get-header-start-with-letter"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "GetHeaderStartWithLetter")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "GetHeaderStartWithLetter")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.Request().Header.Get("headerParam")
		_, isheaderParamExists := ctx.Request().Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required,validate_starts_with_letter"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "GetHeaderStartWithLetter", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "GetHeaderStartWithLetter")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "GetHeaderStartWithLetter")
		value, opError := controller.GetHeaderStartWithLetter(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "GetHeaderStartWithLetter")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetHeaderStartWithLetter'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/GetHeaderStartWithLetter",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "GetHeaderStartWithLetter")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "GetHeaderStartWithLetter")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "GetHeaderStartWithLetter")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "GetHeaderStartWithLetter")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/with-default-config-security"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "WithDefaultConfigSecurity")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "WithDefaultConfigSecurity")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.Request().Header.Get("x-test-scopes")
		_, isheaderParamExists := ctx.Request().Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithDefaultConfigSecurity", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "WithDefaultConfigSecurity")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "WithDefaultConfigSecurity")
		value, opError := controller.WithDefaultConfigSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "WithDefaultConfigSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithDefaultConfigSecurity'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/WithDefaultConfigSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "WithDefaultConfigSecurity")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "WithDefaultConfigSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "WithDefaultConfigSecurity")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "WithDefaultConfigSecurity")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/with-one-security"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "WithOneSecurity")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"other",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "WithOneSecurity")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.Request().Header.Get("x-test-scopes")
		_, isheaderParamExists := ctx.Request().Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithOneSecurity", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "WithOneSecurity")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "WithOneSecurity")
		value, opError := controller.WithOneSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "WithOneSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithOneSecurity'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/WithOneSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "WithOneSecurity")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "WithOneSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "WithOneSecurity")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "WithOneSecurity")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/with-two-security"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "WithTwoSecurity")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"other",
							},
						},
					},
				},
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"write",
								"read",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "WithTwoSecurity")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.Request().Header.Get("x-test-scopes")
		_, isheaderParamExists := ctx.Request().Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithTwoSecurity", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "WithTwoSecurity")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "WithTwoSecurity")
		value, opError := controller.WithTwoSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "WithTwoSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithTwoSecurity'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/WithTwoSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "WithTwoSecurity")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "WithTwoSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "WithTwoSecurity")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "WithTwoSecurity")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/with-two-security-same-method"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "WithTwoSecuritySameMethod")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"other",
							},
						},
					},
				},
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"write",
								"read",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "WithTwoSecuritySameMethod")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.Request().Header.Get("x-test-scopes")
		_, isheaderParamExists := ctx.Request().Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithTwoSecuritySameMethod", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "WithTwoSecuritySameMethod")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "WithTwoSecuritySameMethod")
		value, opError := controller.WithTwoSecuritySameMethod(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "WithTwoSecuritySameMethod")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithTwoSecuritySameMethod'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/WithTwoSecuritySameMethod",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "WithTwoSecuritySameMethod")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "WithTwoSecuritySameMethod")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "WithTwoSecuritySameMethod")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "WithTwoSecuritySameMethod")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/default-error"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "DefaultError")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "DefaultError")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "DefaultError")
		opError := controller.DefaultError()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "DefaultError")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'DefaultError'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/DefaultError",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "DefaultError")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "DefaultError")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "DefaultError")
		ctx.Response().WriteHeader(statusCode)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "DefaultError")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/default-error-with-payload"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "DefaultErrorWithPayload")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "DefaultErrorWithPayload")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "DefaultErrorWithPayload")
		value, opError := controller.DefaultErrorWithPayload()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "DefaultErrorWithPayload")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'DefaultErrorWithPayload'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/DefaultErrorWithPayload",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "DefaultErrorWithPayload")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "DefaultErrorWithPayload")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "DefaultErrorWithPayload")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "DefaultErrorWithPayload")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/custom-error"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "CustomError")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "CustomError")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "CustomError")
		opError := controller.CustomError()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "CustomError")
		statusCode := getStatusCode(&controller, false, opError)
		emptyErr := Response70CustomError.CustomError{}
		if opError != emptyErr {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			return ctx.JSON(statusCode, opError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "CustomError")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "CustomError")
		ctx.Response().WriteHeader(statusCode)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "CustomError")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/custom-error-ptr"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "CustomPtrError")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "CustomPtrError")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "CustomPtrError")
		opError := controller.CustomPtrError()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "CustomPtrError")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			return ctx.JSON(statusCode, opError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "CustomPtrError")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "CustomPtrError")
		ctx.Response().WriteHeader(statusCode)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "CustomPtrError")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/503-error-code"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "Error503")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "Error503")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "Error503")
		opError := controller.Error503()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "Error503")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Error503'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/Error503",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "Error503")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "Error503")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "Error503")
		ctx.Response().WriteHeader(statusCode)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "Error503")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/custom-error-503"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "CustomError503")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "CustomError503")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "CustomError503")
		opError := controller.CustomError503()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "CustomError503")
		statusCode := getStatusCode(&controller, false, opError)
		emptyErr := Response73CustomError.CustomError{}
		if opError != emptyErr {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			return ctx.JSON(statusCode, opError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "CustomError503")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "CustomError503")
		ctx.Response().WriteHeader(statusCode)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "CustomError503")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/context-access"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "ContextAccess")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "ContextAccess")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "ContextAccess")
		opError := controller.ContextAccess()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "ContextAccess")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ContextAccess'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/ContextAccess",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "ContextAccess")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "ContextAccess")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "ContextAccess")
		ctx.Response().WriteHeader(statusCode)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "ContextAccess")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/http-method"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "Get")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "Get")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "Get")
		opError := controller.Get()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "Get")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Get'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/Get",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "Get")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "Get")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "Get")
		ctx.Response().WriteHeader(statusCode)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "Get")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/http-method"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "Post")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "Post")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "Post")
		opError := controller.Post()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "Post")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Post'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/Post",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "Post")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "Post")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "Post")
		ctx.Response().WriteHeader(statusCode)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "Post")
		return nil
	})
	engine.PUT(toEchoUrl("/e2e/http-method"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "Put")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "Put")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "Put")
		opError := controller.Put()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "Put")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Put'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/Put",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "Put")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "Put")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "Put")
		ctx.Response().WriteHeader(statusCode)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "Put")
		return nil
	})
	engine.DELETE(toEchoUrl("/e2e/http-method"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "Delete")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "Delete")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "Delete")
		opError := controller.Delete()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "Delete")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Delete'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/Delete",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "Delete")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "Delete")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "Delete")
		ctx.Response().WriteHeader(statusCode)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "Delete")
		return nil
	})
	engine.PATCH(toEchoUrl("/e2e/http-method"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "Patch")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "Patch")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "Patch")
		opError := controller.Patch()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "Patch")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Patch'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/Patch",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "Patch")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "Patch")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "Patch")
		ctx.Response().WriteHeader(statusCode)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "Patch")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/template-context-1"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "TemplateContext1")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "TemplateContext1")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "TemplateContext1")
		value, opError := controller.TemplateContext1()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "TemplateContext1")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TemplateContext1'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TemplateContext1",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "TemplateContext1")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "TemplateContext1")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "TemplateContext1")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "TemplateContext1")
		ctx.Response().Header().Set("x-level", "high")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/template-context-2"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "TemplateContext2")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "TemplateContext2")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "TemplateContext2")
		value, opError := controller.TemplateContext2()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "TemplateContext2")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TemplateContext2'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TemplateContext2",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "TemplateContext2")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "TemplateContext2")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "TemplateContext2")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "TemplateContext2")
		ctx.Response().Header().Set("x-mode", "100")
		ctx.Response().Header().Set("x-level", "low")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/form"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "TestForm")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "TestForm")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		ctx.Request().ParseForm()
		var item1RawPtr *string = nil
		item1RawArr, isitem1Exists := ctx.Request().PostForm["item1"]
		item1Raw := ""
		if isitem1Exists {
			item1Raw = item1RawArr[0] // Get first value since form values are slices
		}
		if isitem1Exists {
			item1 := item1Raw
			item1RawPtr = &item1
		}
		if validatorErr := validatorInstance.Var(item1RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "item1"
			validationError := wrapValidatorError(validatorErr, "TestForm", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "TestForm")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		ctx.Request().ParseForm()
		var item2RawPtr *string = nil
		item2RawArr, isitem2Exists := ctx.Request().PostForm["item2"]
		item2Raw := ""
		if isitem2Exists {
			item2Raw = item2RawArr[0] // Get first value since form values are slices
		}
		if isitem2Exists {
			item2 := item2Raw
			item2RawPtr = &item2
		}
		if validatorErr := validatorInstance.Var(item2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "item2"
			validationError := wrapValidatorError(validatorErr, "TestForm", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "TestForm")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "TestForm")
		value, opError := controller.TestForm(*item1RawPtr, *item2RawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "TestForm")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestForm'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TestForm",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "TestForm")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "TestForm")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "TestForm")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "TestForm")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/test-response-validation"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "TestResponseValidation")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "TestResponseValidation")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "TestResponseValidation")
		value, opError := controller.TestResponseValidation()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "TestResponseValidation")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidation'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TestResponseValidation",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "TestResponseValidation")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "TestResponseValidation")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidation'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/TestResponseValidation",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "TestResponseValidation")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "TestResponseValidation")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/test-response-validation-ptr"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "TestResponseValidationPtr")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "TestResponseValidationPtr")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "TestResponseValidationPtr")
		value, opError := controller.TestResponseValidationPtr()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "TestResponseValidationPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationPtr'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TestResponseValidationPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "TestResponseValidationPtr")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "TestResponseValidationPtr")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationPtr'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/TestResponseValidationPtr",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "TestResponseValidationPtr")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "TestResponseValidationPtr")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/test-response-validation-null"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "TestResponseValidationNull")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "TestResponseValidationNull")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "TestResponseValidationNull")
		value, opError := controller.TestResponseValidationNull()
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "TestResponseValidationNull")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationNull'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TestResponseValidationNull",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "TestResponseValidationNull")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "TestResponseValidationNull")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationNull'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/TestResponseValidationNull",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "TestResponseValidationNull")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "TestResponseValidationNull")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/test-primitive-conversions"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "TestPrimitiveConversions")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "TestPrimitiveConversions")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var value1RawPtr *int64 = nil
		value1Raw := ctx.QueryParam("value1")
		isvalue1Exists := ctx.Request().URL.Query().Has("value1")
		if isvalue1Exists {
			value1Uint64, conversionErr := strconv.ParseInt(value1Raw, 10, 64)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestPrimitiveConversions' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value1",
						"int64",
						reflect.TypeOf(value1Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/TestPrimitiveConversions",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "TestPrimitiveConversions")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
			value1 := int64(value1Uint64)
			value1RawPtr = &value1
		}
		if validatorErr := validatorInstance.Var(value1RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value1"
			validationError := wrapValidatorError(validatorErr, "TestPrimitiveConversions", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "TestPrimitiveConversions")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		var value2RawPtr *bool = nil
		value2Raw := ctx.QueryParam("value2")
		isvalue2Exists := ctx.Request().URL.Query().Has("value2")
		if isvalue2Exists {
			value2, conversionErr := strconv.ParseBool(value2Raw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestPrimitiveConversions' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value2",
						"bool",
						reflect.TypeOf(value2Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/TestPrimitiveConversions",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "TestPrimitiveConversions")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
			value2RawPtr = &value2
		}
		if validatorErr := validatorInstance.Var(value2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value2"
			validationError := wrapValidatorError(validatorErr, "TestPrimitiveConversions", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "TestPrimitiveConversions")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		var value3RawPtr *int = nil
		value3Raw := ctx.QueryParam("value3")
		isvalue3Exists := ctx.Request().URL.Query().Has("value3")
		if isvalue3Exists {
			value3Uint64, conversionErr := strconv.Atoi(value3Raw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestPrimitiveConversions' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value3",
						"int",
						reflect.TypeOf(value3Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/TestPrimitiveConversions",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "TestPrimitiveConversions")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
			value3 := int(value3Uint64)
			value3RawPtr = &value3
		}
		if validatorErr := validatorInstance.Var(value3RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value3"
			validationError := wrapValidatorError(validatorErr, "TestPrimitiveConversions", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "TestPrimitiveConversions")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		var value4RawPtr *float64 = nil
		value4Raw := ctx.QueryParam("value4")
		isvalue4Exists := ctx.Request().URL.Query().Has("value4")
		if isvalue4Exists {
			value4, conversionErr := strconv.ParseFloat(value4Raw, 64)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestPrimitiveConversions' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value4",
						"float64",
						reflect.TypeOf(value4Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/TestPrimitiveConversions",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "TestPrimitiveConversions")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
			value4RawPtr = &value4
		}
		if validatorErr := validatorInstance.Var(value4RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value4"
			validationError := wrapValidatorError(validatorErr, "TestPrimitiveConversions", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "TestPrimitiveConversions")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "TestPrimitiveConversions")
		value, opError := controller.TestPrimitiveConversions(*value1RawPtr, *value2RawPtr, *value3RawPtr, *value4RawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "TestPrimitiveConversions")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestPrimitiveConversions'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TestPrimitiveConversions",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "TestPrimitiveConversions")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "TestPrimitiveConversions")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "TestPrimitiveConversions")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "TestPrimitiveConversions")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/test-enums"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "TestEnums")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "TestEnums")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var conversionErr error
		var value1RawPtr *Param100value1.StatusEnumeration = nil
		value1Raw := ctx.QueryParam("value1")
		isvalue1Exists := ctx.Request().URL.Query().Has("value1")
		if isvalue1Exists {
			value1 := value1Raw
			switch value1Raw {
			case "active", "inactive":
				value1Var := Param100value1.StatusEnumeration(value1)
				value1RawPtr = &value1Var
			default:
				conversionErr := fmt.Errorf("value1 must be one of \"active, inactive\" options only but got \"%s\"", value1Raw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnums' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value1",
						"StatusEnumeration",
						reflect.TypeOf(value1Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/TestEnums",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnums")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
		}
		if validatorErr := validatorInstance.Var(value1RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value1"
			validationError := wrapValidatorError(validatorErr, "TestEnums", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "TestEnums")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		var value2RawPtr *Param101value2.NumberEnumeration = nil
		value2Raw := ctx.QueryParam("value2")
		isvalue2Exists := ctx.Request().URL.Query().Has("value2")
		if isvalue2Exists {
			value2Uint64, conversionErr := strconv.Atoi(value2Raw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnums' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value2",
						"NumberEnumeration",
						reflect.TypeOf(value2Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/TestEnums",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnums")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
			value2 := int(value2Uint64)
			switch value2Raw {
			case "1", "2":
				value2Var := Param101value2.NumberEnumeration(value2)
				value2RawPtr = &value2Var
			default:
				conversionErr := fmt.Errorf("value2 must be one of \"1, 2\" options only but got \"%s\"", value2Raw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnums' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value2",
						"NumberEnumeration",
						reflect.TypeOf(value2Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/TestEnums",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnums")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
		}
		if validatorErr := validatorInstance.Var(value2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value2"
			validationError := wrapValidatorError(validatorErr, "TestEnums", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "TestEnums")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		var value3RawPtr *Param102value3.ObjectWithEnum = nil
		conversionErr = bindAndValidateBody(ctx, "application/json", "required", &value3RawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, conversionErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'TestEnums' but body parameter '%s' did not pass validation of '%s' - %s",
					"value3",
					"ObjectWithEnum",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/gleece/validation/error/TestEnums",
			}
			ctx.Response().Header().Set("x-JsonBodyValidationErrorResponseExtension", "TestEnums")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "TestEnums")
		value, opError := controller.TestEnums(*value1RawPtr, *value2RawPtr, *value3RawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "TestEnums")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestEnums'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TestEnums",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "TestEnums")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "TestEnums")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'TestEnums'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/TestEnums",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "TestEnums")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "TestEnums")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/test-enums-in-all/{value1}"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "TestEnumsInAll")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "TestEnumsInAll")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var value1RawPtr *Param105value1.StatusEnumeration = nil
		value1Raw := ctx.Param("value1")
		isvalue1Exists := true // if parameter is in route but not provided, it won't reach this handler
		if isvalue1Exists {
			value1 := value1Raw
			switch value1Raw {
			case "active", "inactive":
				value1Var := Param105value1.StatusEnumeration(value1)
				value1RawPtr = &value1Var
			default:
				conversionErr := fmt.Errorf("value1 must be one of \"active, inactive\" options only but got \"%s\"", value1Raw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnumsInAll' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value1",
						"StatusEnumeration",
						reflect.TypeOf(value1Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/TestEnumsInAll",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnumsInAll")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
		}
		if validatorErr := validatorInstance.Var(value1RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value1"
			validationError := wrapValidatorError(validatorErr, "TestEnumsInAll", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "TestEnumsInAll")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		var value2RawPtr *Param106value2.NumberEnumeration = nil
		value2Raw := ctx.Request().Header.Get("value2")
		_, isvalue2Exists := ctx.Request().Header["value2"]
		if !isvalue2Exists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("value2")
			isvalue2Exists = len(headerValues) > 0
		}
		if isvalue2Exists {
			value2Uint64, conversionErr := strconv.Atoi(value2Raw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnumsInAll' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value2",
						"NumberEnumeration",
						reflect.TypeOf(value2Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/TestEnumsInAll",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnumsInAll")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
			value2 := int(value2Uint64)
			switch value2Raw {
			case "1", "2":
				value2Var := Param106value2.NumberEnumeration(value2)
				value2RawPtr = &value2Var
			default:
				conversionErr := fmt.Errorf("value2 must be one of \"1, 2\" options only but got \"%s\"", value2Raw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnumsInAll' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value2",
						"NumberEnumeration",
						reflect.TypeOf(value2Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/TestEnumsInAll",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnumsInAll")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
		}
		if validatorErr := validatorInstance.Var(value2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value2"
			validationError := wrapValidatorError(validatorErr, "TestEnumsInAll", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "TestEnumsInAll")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		ctx.Request().ParseForm()
		var value3RawPtr *Param107value3.StatusEnumeration = nil
		value3RawArr, isvalue3Exists := ctx.Request().PostForm["value3"]
		value3Raw := ""
		if isvalue3Exists {
			value3Raw = value3RawArr[0] // Get first value since form values are slices
		}
		if isvalue3Exists {
			value3 := value3Raw
			switch value3Raw {
			case "active", "inactive":
				value3Var := Param107value3.StatusEnumeration(value3)
				value3RawPtr = &value3Var
			default:
				conversionErr := fmt.Errorf("value3 must be one of \"active, inactive\" options only but got \"%s\"", value3Raw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnumsInAll' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value3",
						"StatusEnumeration",
						reflect.TypeOf(value3Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/TestEnumsInAll",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnumsInAll")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
		}
		if validatorErr := validatorInstance.Var(value3RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value3"
			validationError := wrapValidatorError(validatorErr, "TestEnumsInAll", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "TestEnumsInAll")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "TestEnumsInAll")
		value, opError := controller.TestEnumsInAll(*value1RawPtr, *value2RawPtr, *value3RawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "TestEnumsInAll")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestEnumsInAll'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TestEnumsInAll",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "TestEnumsInAll")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "TestEnumsInAll")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "TestEnumsInAll")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "TestEnumsInAll")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/test-enums-optional"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "TestEnumsOptional")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "TestEnumsOptional")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var value1RawPtr *Param110value1.StatusEnumeration = nil
		value1Raw := ctx.Request().Header.Get("value1")
		_, isvalue1Exists := ctx.Request().Header["value1"]
		if !isvalue1Exists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("value1")
			isvalue1Exists = len(headerValues) > 0
		}
		if isvalue1Exists {
			value1 := value1Raw
			switch value1Raw {
			case "active", "inactive":
				value1Var := Param110value1.StatusEnumeration(value1)
				value1RawPtr = &value1Var
			default:
				conversionErr := fmt.Errorf("value1 must be one of \"active, inactive\" options only but got \"%s\"", value1Raw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnumsOptional' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value1",
						"StatusEnumeration",
						reflect.TypeOf(value1Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/TestEnumsOptional",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnumsOptional")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "TestEnumsOptional")
		value, opError := controller.TestEnumsOptional(value1RawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "TestEnumsOptional")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestEnumsOptional'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/TestEnumsOptional",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "TestEnumsOptional")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "TestEnumsOptional")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "TestEnumsOptional")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "TestEnumsOptional")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/external-packages"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "ExternalPackages")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "ExternalPackages")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var conversionErr error
		var unitRawPtr *Param113unit.LengthUnits = nil
		unitRaw := ctx.QueryParam("unit")
		isunitExists := ctx.Request().URL.Query().Has("unit")
		if isunitExists {
			unit := unitRaw
			switch unitRaw {
			case "Angstrom", "AstronomicalUnit", "Centimeter", "Chain", "DataMile", "Decameter", "Decimeter", "DtpPica", "DtpPoint", "Fathom", "Femtometer", "Foot", "Gigameter", "Hand", "Hectometer", "Inch", "Kilofoot", "KilolightYear", "Kilometer", "Kiloparsec", "Kiloyard", "LightYear", "MegalightYear", "Megameter", "Megaparsec", "Meter", "Microinch", "Micrometer", "Mil", "Mile", "Millimeter", "Nanometer", "NauticalMile", "Parsec", "Picometer", "PrinterPica", "PrinterPoint", "Shackle", "SolarRadius", "Twip", "UsSurveyFoot", "Yard":
				unitVar := Param113unit.LengthUnits(unit)
				unitRawPtr = &unitVar
			default:
				conversionErr := fmt.Errorf("unit must be one of \"Angstrom, AstronomicalUnit, Centimeter, Chain, DataMile, Decameter, Decimeter, DtpPica, DtpPoint, Fathom, Femtometer, Foot, Gigameter, Hand, Hectometer, Inch, Kilofoot, KilolightYear, Kilometer, Kiloparsec, Kiloyard, LightYear, MegalightYear, Megameter, Megaparsec, Meter, Microinch, Micrometer, Mil, Mile, Millimeter, Nanometer, NauticalMile, Parsec, Picometer, PrinterPica, PrinterPoint, Shackle, SolarRadius, Twip, UsSurveyFoot, Yard\" options only but got \"%s\"", unitRaw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'ExternalPackages' but parameter '%s' was not properly sent - Expected %s but got %s",
						"unit",
						"LengthUnits",
						reflect.TypeOf(unitRaw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/ExternalPackages",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "ExternalPackages")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
		}
		var dataRawPtr *Param114data.LengthDto = nil
		conversionErr = bindAndValidateBody(ctx, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, conversionErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ExternalPackages' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"LengthDto",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/gleece/validation/error/ExternalPackages",
			}
			ctx.Response().Header().Set("x-JsonBodyValidationErrorResponseExtension", "ExternalPackages")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "ExternalPackages")
		value, opError := controller.ExternalPackages(unitRawPtr, *dataRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "ExternalPackages")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ExternalPackages'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/ExternalPackages",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "ExternalPackages")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "ExternalPackages")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'ExternalPackages'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/ExternalPackages",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "ExternalPackages")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "ExternalPackages")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/external-packages-validation"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "ExternalPackagesValidation")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "ExternalPackagesValidation")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var conversionErr error
		var unitRawPtr *Param117unit.LengthUnits = nil
		unitRaw := ctx.QueryParam("unit")
		isunitExists := ctx.Request().URL.Query().Has("unit")
		if isunitExists {
			unit := unitRaw
			switch unitRaw {
			case "Angstrom", "AstronomicalUnit", "Centimeter", "Chain", "DataMile", "Decameter", "Decimeter", "DtpPica", "DtpPoint", "Fathom", "Femtometer", "Foot", "Gigameter", "Hand", "Hectometer", "Inch", "Kilofoot", "KilolightYear", "Kilometer", "Kiloparsec", "Kiloyard", "LightYear", "MegalightYear", "Megameter", "Megaparsec", "Meter", "Microinch", "Micrometer", "Mil", "Mile", "Millimeter", "Nanometer", "NauticalMile", "Parsec", "Picometer", "PrinterPica", "PrinterPoint", "Shackle", "SolarRadius", "Twip", "UsSurveyFoot", "Yard":
				unitVar := Param117unit.LengthUnits(unit)
				unitRawPtr = &unitVar
			default:
				conversionErr := fmt.Errorf("unit must be one of \"Angstrom, AstronomicalUnit, Centimeter, Chain, DataMile, Decameter, Decimeter, DtpPica, DtpPoint, Fathom, Femtometer, Foot, Gigameter, Hand, Hectometer, Inch, Kilofoot, KilolightYear, Kilometer, Kiloparsec, Kiloyard, LightYear, MegalightYear, Megameter, Megaparsec, Meter, Microinch, Micrometer, Mil, Mile, Millimeter, Nanometer, NauticalMile, Parsec, Picometer, PrinterPica, PrinterPoint, Shackle, SolarRadius, Twip, UsSurveyFoot, Yard\" options only but got \"%s\"", unitRaw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					if continueOperation := middleware(ctx, conversionErr); !continueOperation {
						return nil
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'ExternalPackagesValidation' but parameter '%s' was not properly sent - Expected %s but got %s",
						"unit",
						"LengthUnits",
						reflect.TypeOf(unitRaw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/gleece/validation/error/ExternalPackagesValidation",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				ctx.Response().Header().Set("x-ParamsValidationErrorResponseExtension", "ExternalPackagesValidation")
				return ctx.JSON(http.StatusUnprocessableEntity, validationError)
			}
		}
		var dataRawPtr *Param118data.LengthDtoWithValidation = nil
		conversionErr = bindAndValidateBody(ctx, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, conversionErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ExternalPackagesValidation' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"LengthDtoWithValidation",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/gleece/validation/error/ExternalPackagesValidation",
			}
			ctx.Response().Header().Set("x-JsonBodyValidationErrorResponseExtension", "ExternalPackagesValidation")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "ExternalPackagesValidation")
		value, opError := controller.ExternalPackagesValidation(unitRawPtr, *dataRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "ExternalPackagesValidation")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ExternalPackagesValidation'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/ExternalPackagesValidation",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "ExternalPackagesValidation")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "ExternalPackagesValidation")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'ExternalPackagesValidation'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/ExternalPackagesValidation",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "ExternalPackagesValidation")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "ExternalPackagesValidation")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/arrays-in-body-and-res"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "ArraysInBodyAndRes")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "ArraysInBodyAndRes")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var conversionErr error
		var dataRawPtr *[]Param121data.LengthDto = nil
		conversionErr = bindAndValidateBody(ctx, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, conversionErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ArraysInBodyAndRes' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"[]LengthDto",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/gleece/validation/error/ArraysInBodyAndRes",
			}
			ctx.Response().Header().Set("x-JsonBodyValidationErrorResponseExtension", "ArraysInBodyAndRes")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "ArraysInBodyAndRes")
		value, opError := controller.ArraysInBodyAndRes(*dataRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "ArraysInBodyAndRes")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ArraysInBodyAndRes'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/ArraysInBodyAndRes",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "ArraysInBodyAndRes")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "ArraysInBodyAndRes")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'ArraysInBodyAndRes'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/ArraysInBodyAndRes",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "ArraysInBodyAndRes")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "ArraysInBodyAndRes")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/arrays-inside-body-and-res"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "ArraysInsideBodyAndRes")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "ArraysInsideBodyAndRes")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var conversionErr error
		var dataRawPtr *[]Param124data.BlaBla = nil
		conversionErr = bindAndValidateBody(ctx, "application/json", "", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, conversionErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ArraysInsideBodyAndRes' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"[]BlaBla",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/gleece/validation/error/ArraysInsideBodyAndRes",
			}
			ctx.Response().Header().Set("x-JsonBodyValidationErrorResponseExtension", "ArraysInsideBodyAndRes")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "ArraysInsideBodyAndRes")
		value, opError := controller.ArraysInsideBodyAndRes(dataRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "ArraysInsideBodyAndRes")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ArraysInsideBodyAndRes'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/ArraysInsideBodyAndRes",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "ArraysInsideBodyAndRes")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "ArraysInsideBodyAndRes")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'ArraysInsideBodyAndRes'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/ArraysInsideBodyAndRes",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "ArraysInsideBodyAndRes")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "ArraysInsideBodyAndRes")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/deep-arrays-with-validation"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "DeepArraysWithValidation")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "DeepArraysWithValidation")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var conversionErr error
		var dataRawPtr *[][]Param127data.BlaBla2 = nil
		conversionErr = bindAndValidateBody(ctx, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, conversionErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'DeepArraysWithValidation' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"[][]BlaBla2",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/gleece/validation/error/DeepArraysWithValidation",
			}
			ctx.Response().Header().Set("x-JsonBodyValidationErrorResponseExtension", "DeepArraysWithValidation")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "DeepArraysWithValidation")
		value, opError := controller.DeepArraysWithValidation(*dataRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "DeepArraysWithValidation")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'DeepArraysWithValidation'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/DeepArraysWithValidation",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "DeepArraysWithValidation")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "DeepArraysWithValidation")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'DeepArraysWithValidation'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/DeepArraysWithValidation",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "DeepArraysWithValidation")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "DeepArraysWithValidation")
		return nil
	})
	engine.POST(toEchoUrl("/e2e/embedded-structs"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "EmbeddedStructs")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "EmbeddedStructs")
		}
		controller := E2EControllerImport.E2EController{}
		controller.InitController(ctx)
		var conversionErr error
		var dataRawPtr *Param130data.TheModel = nil
		conversionErr = bindAndValidateBody(ctx, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, conversionErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'EmbeddedStructs' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"TheModel",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/gleece/validation/error/EmbeddedStructs",
			}
			ctx.Response().Header().Set("x-JsonBodyValidationErrorResponseExtension", "EmbeddedStructs")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "EmbeddedStructs")
		value, opError := controller.EmbeddedStructs(*dataRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "EmbeddedStructs")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'EmbeddedStructs'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/EmbeddedStructs",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "EmbeddedStructs")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "EmbeddedStructs")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				if continueOperation := middleware(ctx, outputValidationErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'EmbeddedStructs'",
				Status:     outputValidationStatusCode,
				Instance:   "/gleece/controller/error/EmbeddedStructs",
				Extensions: map[string]string{},
			}
			return ctx.JSON(outputValidationStatusCode, outputValidationRfc7807Error)
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "EmbeddedStructs")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "EmbeddedStructs")
		return nil
	})
	// E2EClassSecController
	engine.GET(toEchoUrl("/e2e/with-default-class-security"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "WithDefaultClassSecurity")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"class",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "WithDefaultClassSecurity")
		}
		controller := E2EClassSecControllerImport.E2EClassSecController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.Request().Header.Get("x-test-scopes")
		_, isheaderParamExists := ctx.Request().Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithDefaultClassSecurity", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "WithDefaultClassSecurity")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "WithDefaultClassSecurity")
		value, opError := controller.WithDefaultClassSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "WithDefaultClassSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithDefaultClassSecurity'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/WithDefaultClassSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "WithDefaultClassSecurity")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "WithDefaultClassSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "WithDefaultClassSecurity")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "WithDefaultClassSecurity")
		return nil
	})
	engine.GET(toEchoUrl("/e2e/with-default-override-class-security"), func(ctx echo.Context) error {
		ctx.Response().Header().Set("x-RouteStartRoutesExtension", "WithOverrideClassSecurity")
		authErr := authorize(
			ctx,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"method",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			return handleAuthorizationError(ctx, authErr, "WithOverrideClassSecurity")
		}
		controller := E2EClassSecControllerImport.E2EClassSecController{}
		controller.InitController(ctx)
		var headerParamRawPtr *string = nil
		headerParamRaw := ctx.Request().Header.Get("x-test-scopes")
		_, isheaderParamExists := ctx.Request().Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the ctx.Request().Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := ctx.Request().Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				if continueOperation := middleware(ctx, validatorErr); !continueOperation {
					return nil
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithOverrideClassSecurity", fieldName)
			ctx.Response().Header().Set("x-RunValidatorExtension", "WithOverrideClassSecurity")
			return ctx.JSON(http.StatusUnprocessableEntity, validationError)
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares beforeOperationMiddlewares section
		ctx.Response().Header().Set("x-BeforeOperationRoutesExtension", "WithOverrideClassSecurity")
		value, opError := controller.WithOverrideClassSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			ctx.Response().Header().Set(key, value)
		}
		ctx.Response().Header().Set("x-inject", "true")
		ctx.Response().Header().Set("x-ResponseHeadersExtension", "WithOverrideClassSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				if continueOperation := middleware(ctx, opError); !continueOperation {
					return nil
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithOverrideClassSecurity'",
				Status:     statusCode,
				Instance:   "/gleece/controller/error/WithOverrideClassSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			ctx.Response().Header().Set("x-JsonErrorResponseExtension", "WithOverrideClassSecurity")
			return ctx.JSON(statusCode, stdError)
		}
		ctx.Response().Header().Set("x-JsonResponseExtension", "WithOverrideClassSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			if continueOperation := middleware(ctx); !continueOperation {
				return nil
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		ctx.Response().Header().Set("x-AfterOperationRoutesExtension", "WithOverrideClassSecurity")
		ctx.JSON(statusCode, value)
		ctx.Response().Header().Set("x-RouteEndRoutesExtension", "WithOverrideClassSecurity")
		return nil
	})
}
