/*
--
This file is automatically generated. Any manual changes to this file may be overwritten.
It includes routes and handlers by the Gleece API Routes Generator.
--
Authors: Haim Kastner & Yuval Pomerchik
Generated by: Gleece Routes Generator
2025-08-10
Target Engine: Chi v5 (https://github.com/go-chi/chi)
--
Usage:
Refer to the Gleece documentation https://docs.gleece.dev for details on how to use the generated routes and handlers.
--
Repository: https://github.com/gopher-fleece/gleece
--
*/
package routes
import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"github.com/go-chi/chi/v5"
	"github.com/go-playground/validator/v10"
	RequestAuth "github.com/gopher-fleece/gleece/e2e/chi/auth"
	"github.com/gopher-fleece/runtime"
	E2EClassSecController "github.com/gopher-fleece/gleece/e2e/assets"
	E2EController "github.com/gopher-fleece/gleece/e2e/assets"
	Param11value3 "github.com/gopher-fleece/gleece/e2e/assets"
	Param12value1 "github.com/gopher-fleece/gleece/e2e/assets"
	Param12value3 "github.com/gopher-fleece/gleece/e2e/assets"
	Param15data "github.com/gopher-fleece/gleece/e2e/assets"
	Param16data "github.com/gopher-fleece/gleece/e2e/assets"
	Param17data "github.com/gopher-fleece/gleece/e2e/assets"
	Param18data "github.com/gopher-fleece/gleece/e2e/assets"
	Param19data "github.com/gopher-fleece/gleece/e2e/assets"
	Param20data "github.com/gopher-fleece/gleece/e2e/assets"
	Param4value2 "github.com/gopher-fleece/gleece/e2e/assets"
	Param5theBody "github.com/gopher-fleece/gleece/e2e/assets"
	Response6CustomError "github.com/gopher-fleece/gleece/e2e/assets"
	Param13data "github.com/haimkastner/unitsnet-go/units"
	Param14unit "github.com/haimkastner/unitsnet-go/units"
	// ImportsExtension - test
)
var validatorInstance = validator.New()
var urlParamRegex *regexp.Regexp
type SecurityListRelation string
const (
	SecurityListRelationAnd SecurityListRelation = "AND"
)
type SecurityCheckList struct {
	Checks   []runtime.SecurityCheck
	Relation SecurityListRelation
}
// TypeDeclarationsExtension - test
func getRequestContext(req *http.Request) context.Context {
	return req.Context()
}
func setRequestContext(req *http.Request, ctx context.Context) {
	if ctx != nil {
		*req = *req.WithContext(ctx)
	}
}
func registerEnumValidation(validate *validator.Validate, validationName string, allowedValues []string) {
	// Convert the array to a map for O(1) lookup
	lookup := make(map[string]struct{})
	for _, val := range allowedValues {
		lookup[val] = struct{}{}
	}
	// Register the custom validation
	validate.RegisterValidation(validationName, func(fl validator.FieldLevel) bool {
		field := fl.Field().String()
		_, exists := lookup[field]
		return exists
	})
}
func extractValidationErrorMessage(err error, fieldName *string) string {
	if err == nil {
		return ""
	}
	validationErrors, ok := err.(validator.ValidationErrors)
	if !ok {
		return err.Error()
	}
	var errStr string
	for _, validationErr := range validationErrors {
		fName := validationErr.Field()
		if fieldName != nil {
			fName = *fieldName
		}
		errStr += fmt.Sprintf("Field '%s' failed validation with tag '%s'. ", fName, validationErr.Tag())
	}
	return errStr
}
func getStatusCode(controller runtime.Controller, hasReturnValue bool, err error) int {
	if controller.GetStatus() != nil {
		return int(*controller.GetStatus())
	}
	if err != nil {
		return http.StatusInternalServerError
	}
	if hasReturnValue {
		return http.StatusOK
	}
	return http.StatusNoContent
}
func bindAndValidateBody[TOutput any](req *http.Request, contentType string, validation string, output **TOutput) error {
	var err error
	bodyBytes, err := io.ReadAll(req.Body)
	if err != nil || len(bodyBytes) == 0 {
		if strings.Contains(validation, "required") {
			return fmt.Errorf("body is required but was not provided")
		}
		return nil
	}
	var deserializedOutput TOutput
	switch contentType {
	case "application/json":
		err = json.Unmarshal(bodyBytes, &deserializedOutput)
	default:
		return fmt.Errorf("content-type %s is not currently supported by the validation subsystem", contentType)
	}
	if err != nil {
		return err
	}
	// Validate the unmarshaled data recursively
	if err = validateDataRecursive(deserializedOutput, ""); err != nil {
		return err
	}
	*output = &deserializedOutput
	return nil
}
func validateDataRecursive(data interface{}, path string) error {
	val := reflect.ValueOf(data)
	// Handle pointers by dereferencing
	if val.Kind() == reflect.Ptr {
		if val.IsNil() {
			return nil
		}
		return validateDataRecursive(val.Elem().Interface(), path)
	}
	// Handle different types
	switch val.Kind() {
	case reflect.Slice, reflect.Array:
		// For slices/arrays, validate each element recursively
		for i := 0; i < val.Len(); i++ {
			elemPath := path
			if path != "" {
				elemPath = fmt.Sprintf("%s[%d]", path, i)
			} else {
				elemPath = fmt.Sprintf("[%d]", i)
			}
			// Get the element - handle case where element might be nil
			elem := val.Index(i)
			if elem.Kind() == reflect.Ptr && elem.IsNil() {
				continue
			}
			// Validate the element recursively
			if err := validateDataRecursive(elem.Interface(), elemPath); err != nil {
				return err
			}
		}
		return nil
	case reflect.Map:
		// For maps, validate each value recursively
		for _, key := range val.MapKeys() {
			elemPath := path
			if path != "" {
				elemPath = fmt.Sprintf("%s.%v", path, key.Interface())
			} else {
				elemPath = fmt.Sprintf("%v", key.Interface())
			}
			elemVal := val.MapIndex(key)
			if elemVal.Kind() == reflect.Ptr && elemVal.IsNil() {
				continue
			}
			if err := validateDataRecursive(elemVal.Interface(), elemPath); err != nil {
				return err
			}
		}
		return nil
	case reflect.Struct:
		// Validate structs with the validator
		if err := validatorInstance.Struct(data); err != nil {
			if path != "" {
				return fmt.Errorf("validation error at %s: %w", path, err)
			}
			return err
		}
		return nil
	default:
		// Primitive types don't need validation
		return nil
	}
}
func toChiUrl(url string) string {
	return url
}
func authorize(req *http.Request, checksLists []SecurityCheckList) *runtime.SecurityError {
	var lastError *runtime.SecurityError
	for _, list := range checksLists {
		if list.Relation != SecurityListRelationAnd {
			panic(
				"Encountered a security list relation of type '%s' - this is unexpected and indicates a bug in Gleece itself." +
					"Please open an issue at https://github.com/gopher-fleece/gleece/issues",
			)
		}
		// Iterate over each security list
		encounteredErrorInList := false
		for _, check := range list.Checks {
			secCtx, secErr := RequestAuth.GleeceRequestAuthorization(getRequestContext(req), req, check)
			setRequestContext(req, secCtx)
			if secErr != nil {
				lastError = secErr
				encounteredErrorInList = true
				break
			}
		}
		// If no error was encountered, validation is considered successful
		// otherwise, we continue over to the next iteration whilst keeping track of the last error
		if !encounteredErrorInList {
			return nil
		}
	}
	// If we got here it means authentication has failed
	return lastError
}
func handleAuthorizationError(w http.ResponseWriter, authErr *runtime.SecurityError, operationId string) {
	statusCode := int(authErr.StatusCode)
	if authErr.CustomError != nil {
		// For now, we support JSON only
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(authErr.CustomError.Payload)
		return
	}
	stdError := runtime.Rfc7807Error{
		Type:     http.StatusText(statusCode),
		Detail:   authErr.Message,
		Status:   statusCode,
		Instance: "/authorization/error/" + operationId,
	}
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(stdError)
}
func wrapValidatorError(validatorErr error, operationId string, fieldName string) runtime.Rfc7807Error {
	return runtime.Rfc7807Error{
		Type: http.StatusText(http.StatusUnprocessableEntity),
		Detail: fmt.Sprintf(
			"A request was made to operation '%s' but parameter '%s' did not pass validation - %s",
			operationId,
			fieldName,
			extractValidationErrorMessage(validatorErr, &fieldName),
		),
		Status:   http.StatusUnprocessableEntity,
		Instance: fmt.Sprintf("/validation/error/%s", operationId),
	}
}
// FunctionDeclarationsExtension - test
type MiddlewareFunc func(ctx context.Context, w http.ResponseWriter, r *http.Request) (context.Context, bool)
type ErrorMiddlewareFunc func(ctx context.Context, w http.ResponseWriter, r *http.Request, err error) (context.Context, bool)
var beforeOperationMiddlewares []MiddlewareFunc
var afterOperationSuccessMiddlewares []MiddlewareFunc
var onErrorMiddlewares []ErrorMiddlewareFunc
var onInputValidationMiddlewares []ErrorMiddlewareFunc
var onOutputValidationMiddlewares []ErrorMiddlewareFunc
func RegisterMiddleware(executionType runtime.MiddlewareExecutionType, middlewareFunc MiddlewareFunc) {
	switch executionType {
	case runtime.BeforeOperation:
		beforeOperationMiddlewares = append(beforeOperationMiddlewares, middlewareFunc)
	case runtime.AfterOperationSuccess:
		afterOperationSuccessMiddlewares = append(afterOperationSuccessMiddlewares, middlewareFunc)
	}
}
func RegisterErrorMiddleware(executionType runtime.ErrorMiddlewareExecutionType, errorMiddlewareFunc ErrorMiddlewareFunc) {
	switch executionType {
	case runtime.OnInputValidationError:
		onInputValidationMiddlewares = append(onInputValidationMiddlewares, errorMiddlewareFunc)
	case runtime.OnOutputValidationError:
		onOutputValidationMiddlewares = append(onOutputValidationMiddlewares, errorMiddlewareFunc)
	case runtime.OnOperationError:
		onErrorMiddlewares = append(onErrorMiddlewares, errorMiddlewareFunc)
	}
}
func RegisterCustomValidator(validateTagName string, validateFunc runtime.ValidationFunc) {
	validatorInstance.RegisterValidation(validateTagName, func(fl validator.FieldLevel) bool {
		return validateFunc(fl)
	})
}
func RegisterRoutes(engine *chi.Mux) {
	urlParamRegex = regexp.MustCompile(`\{([\w\d-_]+)\}`)
	registerEnumValidation(validatorInstance, "length_units_enum", []string{"Angstrom", "AstronomicalUnit", "Centimeter", "Chain", "DataMile", "Decameter", "Decimeter", "DtpPica", "DtpPoint", "Fathom", "Femtometer", "Foot", "Gigameter", "Hand", "Hectometer", "Inch", "Kilofoot", "KilolightYear", "Kilometer", "Kiloparsec", "Kiloyard", "LightYear", "MegalightYear", "Megameter", "Megaparsec", "Meter", "Microinch", "Micrometer", "Mil", "Mile", "Millimeter", "Nanometer", "NauticalMile", "Parsec", "Picometer", "PrinterPica", "PrinterPoint", "Shackle", "SolarRadius", "Twip", "UsSurveyFoot", "Yard"})
	registerEnumValidation(validatorInstance, "number_enumeration_enum", []string{"1", "2"})
	registerEnumValidation(validatorInstance, "speed_units_enum", []string{"CentimeterPerHour", "CentimeterPerMinute", "CentimeterPerSecond", "DecimeterPerMinute", "DecimeterPerSecond", "FootPerHour", "FootPerMinute", "FootPerSecond", "InchPerHour", "InchPerMinute", "InchPerSecond", "KilometerPerHour", "KilometerPerMinute", "KilometerPerSecond", "Knot", "Mach", "MeterPerHour", "MeterPerMinute", "MeterPerSecond", "MicrometerPerMinute", "MicrometerPerSecond", "MilePerHour", "MillimeterPerHour", "MillimeterPerMinute", "MillimeterPerSecond", "NanometerPerMinute", "NanometerPerSecond", "UsSurveyFootPerHour", "UsSurveyFootPerMinute", "UsSurveyFootPerSecond", "YardPerHour", "YardPerMinute", "YardPerSecond"})
	registerEnumValidation(validatorInstance, "status_enumeration_enum", []string{"active", "inactive"})
	// RegisterRoutesExtension - test
	// E2EController
	engine.Get(toChiUrl("/e2e/simple-get"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "SimpleGet")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGet")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "SimpleGet")
		value, opError := controller.SimpleGet()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "SimpleGet")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGet'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGet",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "SimpleGet")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "SimpleGet")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "SimpleGet")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "SimpleGet")
	})
	engine.Get(toChiUrl("/e2e/simple-get-empty-string"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "SimpleGetEmptyString")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetEmptyString")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetEmptyString")
		value, opError := controller.SimpleGetEmptyString()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "SimpleGetEmptyString")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetEmptyString'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetEmptyString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "SimpleGetEmptyString")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "SimpleGetEmptyString")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "SimpleGetEmptyString")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "SimpleGetEmptyString")
	})
	engine.Get(toChiUrl("/e2e/simple-get-ptr-string"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "SimpleGetPtrString")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetPtrString")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetPtrString")
		value, opError := controller.SimpleGetPtrString()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "SimpleGetPtrString")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetPtrString'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetPtrString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "SimpleGetPtrString")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "SimpleGetPtrString")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "SimpleGetPtrString")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "SimpleGetPtrString")
	})
	engine.Get(toChiUrl("/e2e/simple-get-null-string"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "SimpleGetNullString")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetNullString")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetNullString")
		value, opError := controller.SimpleGetNullString()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "SimpleGetNullString")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetNullString'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetNullString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "SimpleGetNullString")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "SimpleGetNullString")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "SimpleGetNullString")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "SimpleGetNullString")
	})
	engine.Get(toChiUrl("/e2e/simple-get-object"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "SimpleGetObject")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetObject")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetObject")
		value, opError := controller.SimpleGetObject()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "SimpleGetObject")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObject'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetObject",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "SimpleGetObject")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "SimpleGetObject")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObject'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/SimpleGetObject",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "SimpleGetObject")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "SimpleGetObject")
	})
	engine.Get(toChiUrl("/e2e/simple-get-object-ptr"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "SimpleGetObjectPtr")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetObjectPtr")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetObjectPtr")
		value, opError := controller.SimpleGetObjectPtr()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "SimpleGetObjectPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectPtr'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetObjectPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "SimpleGetObjectPtr")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "SimpleGetObjectPtr")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectPtr'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/SimpleGetObjectPtr",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "SimpleGetObjectPtr")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "SimpleGetObjectPtr")
	})
	engine.Get(toChiUrl("/e2e/simple-get-object-null"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "SimpleGetObjectNull")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetObjectNull")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetObjectNull")
		value, opError := controller.SimpleGetObjectNull()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "SimpleGetObjectNull")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectNull'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetObjectNull",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "SimpleGetObjectNull")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "SimpleGetObjectNull")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectNull'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/SimpleGetObjectNull",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "SimpleGetObjectNull")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "SimpleGetObjectNull")
	})
	engine.Get(toChiUrl("/e2e/primitive-return-type"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "PrimitiveReturnType")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PrimitiveReturnType")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "PrimitiveReturnType")
		value, opError := controller.PrimitiveReturnType()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "PrimitiveReturnType")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PrimitiveReturnType'",
				Status:     statusCode,
				Instance:   "/controller/error/PrimitiveReturnType",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "PrimitiveReturnType")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "PrimitiveReturnType")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "PrimitiveReturnType")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "PrimitiveReturnType")
	})
	engine.Get(toChiUrl("/e2e/primitive-array-return-type"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "PrimitiveArrayReturnType")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PrimitiveArrayReturnType")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "PrimitiveArrayReturnType")
		value, opError := controller.PrimitiveArrayReturnType()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "PrimitiveArrayReturnType")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PrimitiveArrayReturnType'",
				Status:     statusCode,
				Instance:   "/controller/error/PrimitiveArrayReturnType",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "PrimitiveArrayReturnType")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "PrimitiveArrayReturnType")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "PrimitiveArrayReturnType")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "PrimitiveArrayReturnType")
	})
	engine.Get(toChiUrl("/e2e/primitive-alias-return-type"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "PrimitiveAliasReturnType")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PrimitiveAliasReturnType")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "PrimitiveAliasReturnType")
		value, opError := controller.PrimitiveAliasReturnType()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "PrimitiveAliasReturnType")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PrimitiveAliasReturnType'",
				Status:     statusCode,
				Instance:   "/controller/error/PrimitiveAliasReturnType",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "PrimitiveAliasReturnType")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "PrimitiveAliasReturnType")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'PrimitiveAliasReturnType'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/PrimitiveAliasReturnType",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "PrimitiveAliasReturnType")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "PrimitiveAliasReturnType")
	})
	engine.Get(toChiUrl("/e2e/primitive-alias-array-return-type"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "PrimitiveAliasArrayReturnType")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PrimitiveAliasArrayReturnType")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "PrimitiveAliasArrayReturnType")
		value, opError := controller.PrimitiveAliasArrayReturnType()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "PrimitiveAliasArrayReturnType")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PrimitiveAliasArrayReturnType'",
				Status:     statusCode,
				Instance:   "/controller/error/PrimitiveAliasArrayReturnType",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "PrimitiveAliasArrayReturnType")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "PrimitiveAliasArrayReturnType")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'PrimitiveAliasArrayReturnType'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/PrimitiveAliasArrayReturnType",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "PrimitiveAliasArrayReturnType")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "PrimitiveAliasArrayReturnType")
	})
	engine.Get(toChiUrl("/e2e/simple-get-empty"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "SimpleGetEmpty")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetEmpty")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var queryParamRawPtr *string = nil
		queryParamRaw := req.URL.Query().Get("queryParam")
		isqueryParamExists := req.URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "SimpleGetEmpty", fieldName)
			w.Header().Set("x-RunValidatorExtension", "SimpleGetEmpty")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "SimpleGetEmpty")
		opError := controller.SimpleGetEmpty(*queryParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "SimpleGetEmpty")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetEmpty'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetEmpty",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "SimpleGetEmpty")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "SimpleGetEmpty")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "SimpleGetEmpty")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "SimpleGetEmpty")
	})
	engine.Get(toChiUrl("/e2e/get-with-all-params/{pathParam}"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "GetWithAllParams")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "GetWithAllParams")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var queryParamRawPtr *string = nil
		queryParamRaw := req.URL.Query().Get("queryParam")
		isqueryParamExists := req.URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParams", fieldName)
			w.Header().Set("x-RunValidatorExtension", "GetWithAllParams")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var pathParamRawPtr *string = nil
		pathParamRaw := chi.URLParam(req, "pathParam")
		ispathParamExists := true // if parameter is in route but not provided, it won't reach this handler
		if ispathParamExists {
			pathParam := pathParamRaw
			pathParamRawPtr = &pathParam
		}
		if validatorErr := validatorInstance.Var(pathParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "pathParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParams", fieldName)
			w.Header().Set("x-RunValidatorExtension", "GetWithAllParams")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("headerParam")
		_, isheaderParamExists := req.Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParams", fieldName)
			w.Header().Set("x-RunValidatorExtension", "GetWithAllParams")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "GetWithAllParams")
		value, opError := controller.GetWithAllParams(*queryParamRawPtr, *pathParamRawPtr, *headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "GetWithAllParams")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetWithAllParams'",
				Status:     statusCode,
				Instance:   "/controller/error/GetWithAllParams",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "GetWithAllParams")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "GetWithAllParams")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "GetWithAllParams")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "GetWithAllParams")
	})
	engine.Get(toChiUrl("/e2e/get-with-all-params-ptr/{pathParam}"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "GetWithAllParamsPtr")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "GetWithAllParamsPtr")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var queryParamRawPtr *string = nil
		queryParamRaw := req.URL.Query().Get("queryParam")
		isqueryParamExists := req.URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		var pathParamRawPtr *string = nil
		pathParamRaw := chi.URLParam(req, "pathParam")
		ispathParamExists := true // if parameter is in route but not provided, it won't reach this handler
		if ispathParamExists {
			pathParam := pathParamRaw
			pathParamRawPtr = &pathParam
		}
		if validatorErr := validatorInstance.Var(pathParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "pathParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsPtr", fieldName)
			w.Header().Set("x-RunValidatorExtension", "GetWithAllParamsPtr")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("headerParam")
		_, isheaderParamExists := req.Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "GetWithAllParamsPtr")
		value, opError := controller.GetWithAllParamsPtr(queryParamRawPtr, pathParamRawPtr, headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "GetWithAllParamsPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetWithAllParamsPtr'",
				Status:     statusCode,
				Instance:   "/controller/error/GetWithAllParamsPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "GetWithAllParamsPtr")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "GetWithAllParamsPtr")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "GetWithAllParamsPtr")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "GetWithAllParamsPtr")
	})
	engine.Get(toChiUrl("/e2e/get-with-all-params-required-ptr/{pathParam}"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "GetWithAllParamsRequiredPtr")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "GetWithAllParamsRequiredPtr")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var queryParamRawPtr *string = nil
		queryParamRaw := req.URL.Query().Get("queryParam")
		isqueryParamExists := req.URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsRequiredPtr", fieldName)
			w.Header().Set("x-RunValidatorExtension", "GetWithAllParamsRequiredPtr")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var pathParamRawPtr *string = nil
		pathParamRaw := chi.URLParam(req, "pathParam")
		ispathParamExists := true // if parameter is in route but not provided, it won't reach this handler
		if ispathParamExists {
			pathParam := pathParamRaw
			pathParamRawPtr = &pathParam
		}
		if validatorErr := validatorInstance.Var(pathParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "pathParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsRequiredPtr", fieldName)
			w.Header().Set("x-RunValidatorExtension", "GetWithAllParamsRequiredPtr")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("headerParam")
		_, isheaderParamExists := req.Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsRequiredPtr", fieldName)
			w.Header().Set("x-RunValidatorExtension", "GetWithAllParamsRequiredPtr")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "GetWithAllParamsRequiredPtr")
		value, opError := controller.GetWithAllParamsRequiredPtr(queryParamRawPtr, pathParamRawPtr, headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "GetWithAllParamsRequiredPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetWithAllParamsRequiredPtr'",
				Status:     statusCode,
				Instance:   "/controller/error/GetWithAllParamsRequiredPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "GetWithAllParamsRequiredPtr")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "GetWithAllParamsRequiredPtr")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "GetWithAllParamsRequiredPtr")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "GetWithAllParamsRequiredPtr")
	})
	engine.Post(toChiUrl("/e2e/post-with-all-params-body"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "PostWithAllParamsWithBody")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PostWithAllParamsWithBody")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var queryParamRawPtr *string = nil
		queryParamRaw := req.URL.Query().Get("queryParam")
		isqueryParamExists := req.URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "PostWithAllParamsWithBody", fieldName)
			w.Header().Set("x-RunValidatorExtension", "PostWithAllParamsWithBody")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("headerParam")
		_, isheaderParamExists := req.Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "PostWithAllParamsWithBody", fieldName)
			w.Header().Set("x-RunValidatorExtension", "PostWithAllParamsWithBody")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var theBodyRawPtr *Param5theBody.BodyInfo = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &theBodyRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'PostWithAllParamsWithBody' but body parameter '%s' did not pass validation of '%s' - %s",
					"theBody",
					"BodyInfo",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/PostWithAllParamsWithBody",
			}
			w.Header().Set("x-JsonBodyValidationErrorResponseExtension", "PostWithAllParamsWithBody")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "PostWithAllParamsWithBody")
		value, opError := controller.PostWithAllParamsWithBody(*queryParamRawPtr, *headerParamRawPtr, *theBodyRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "PostWithAllParamsWithBody")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBody'",
				Status:     statusCode,
				Instance:   "/controller/error/PostWithAllParamsWithBody",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "PostWithAllParamsWithBody")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "PostWithAllParamsWithBody")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBody'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/PostWithAllParamsWithBody",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "PostWithAllParamsWithBody")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "PostWithAllParamsWithBody")
	})
	engine.Post(toChiUrl("/e2e/post-with-all-params-body-ptr"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "PostWithAllParamsWithBodyPtr")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PostWithAllParamsWithBodyPtr")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var queryParamRawPtr *string = nil
		queryParamRaw := req.URL.Query().Get("queryParam")
		isqueryParamExists := req.URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("headerParam")
		_, isheaderParamExists := req.Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		var theBodyRawPtr *Param5theBody.BodyInfo = nil
		conversionErr = bindAndValidateBody(req, "application/json", "", &theBodyRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'PostWithAllParamsWithBodyPtr' but body parameter '%s' did not pass validation of '%s' - %s",
					"theBody",
					"BodyInfo",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/PostWithAllParamsWithBodyPtr",
			}
			w.Header().Set("x-JsonBodyValidationErrorResponseExtension", "PostWithAllParamsWithBodyPtr")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "PostWithAllParamsWithBodyPtr")
		value, opError := controller.PostWithAllParamsWithBodyPtr(queryParamRawPtr, headerParamRawPtr, theBodyRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "PostWithAllParamsWithBodyPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyPtr'",
				Status:     statusCode,
				Instance:   "/controller/error/PostWithAllParamsWithBodyPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "PostWithAllParamsWithBodyPtr")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "PostWithAllParamsWithBodyPtr")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyPtr'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/PostWithAllParamsWithBodyPtr",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "PostWithAllParamsWithBodyPtr")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "PostWithAllParamsWithBodyPtr")
	})
	engine.Post(toChiUrl("/e2e/post-with-all-params-body-required-ptr"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "PostWithAllParamsWithBodyRequiredPtr")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PostWithAllParamsWithBodyRequiredPtr")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var theBodyRawPtr *Param5theBody.BodyInfo = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &theBodyRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'PostWithAllParamsWithBodyRequiredPtr' but body parameter '%s' did not pass validation of '%s' - %s",
					"theBody",
					"BodyInfo",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/PostWithAllParamsWithBodyRequiredPtr",
			}
			w.Header().Set("x-JsonBodyValidationErrorResponseExtension", "PostWithAllParamsWithBodyRequiredPtr")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "PostWithAllParamsWithBodyRequiredPtr")
		value, opError := controller.PostWithAllParamsWithBodyRequiredPtr(theBodyRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "PostWithAllParamsWithBodyRequiredPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyRequiredPtr'",
				Status:     statusCode,
				Instance:   "/controller/error/PostWithAllParamsWithBodyRequiredPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "PostWithAllParamsWithBodyRequiredPtr")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "PostWithAllParamsWithBodyRequiredPtr")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyRequiredPtr'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/PostWithAllParamsWithBodyRequiredPtr",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "PostWithAllParamsWithBodyRequiredPtr")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "PostWithAllParamsWithBodyRequiredPtr")
	})
	engine.Get(toChiUrl("/e2e/get-header-start-with-letter"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "GetHeaderStartWithLetter")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "GetHeaderStartWithLetter")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("headerParam")
		_, isheaderParamExists := req.Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required,validate_starts_with_letter"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "GetHeaderStartWithLetter", fieldName)
			w.Header().Set("x-RunValidatorExtension", "GetHeaderStartWithLetter")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "GetHeaderStartWithLetter")
		value, opError := controller.GetHeaderStartWithLetter(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "GetHeaderStartWithLetter")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetHeaderStartWithLetter'",
				Status:     statusCode,
				Instance:   "/controller/error/GetHeaderStartWithLetter",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "GetHeaderStartWithLetter")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "GetHeaderStartWithLetter")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "GetHeaderStartWithLetter")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "GetHeaderStartWithLetter")
	})
	engine.Get(toChiUrl("/e2e/with-default-config-security"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "WithDefaultConfigSecurity")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "WithDefaultConfigSecurity")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("x-test-scopes")
		_, isheaderParamExists := req.Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithDefaultConfigSecurity", fieldName)
			w.Header().Set("x-RunValidatorExtension", "WithDefaultConfigSecurity")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "WithDefaultConfigSecurity")
		value, opError := controller.WithDefaultConfigSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "WithDefaultConfigSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithDefaultConfigSecurity'",
				Status:     statusCode,
				Instance:   "/controller/error/WithDefaultConfigSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "WithDefaultConfigSecurity")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "WithDefaultConfigSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "WithDefaultConfigSecurity")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "WithDefaultConfigSecurity")
	})
	engine.Get(toChiUrl("/e2e/with-one-security"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "WithOneSecurity")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"other",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "WithOneSecurity")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("x-test-scopes")
		_, isheaderParamExists := req.Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithOneSecurity", fieldName)
			w.Header().Set("x-RunValidatorExtension", "WithOneSecurity")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "WithOneSecurity")
		value, opError := controller.WithOneSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "WithOneSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithOneSecurity'",
				Status:     statusCode,
				Instance:   "/controller/error/WithOneSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "WithOneSecurity")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "WithOneSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "WithOneSecurity")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "WithOneSecurity")
	})
	engine.Get(toChiUrl("/e2e/with-two-security"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "WithTwoSecurity")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"other",
							},
						},
					},
				},
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"write",
								"read",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "WithTwoSecurity")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("x-test-scopes")
		_, isheaderParamExists := req.Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithTwoSecurity", fieldName)
			w.Header().Set("x-RunValidatorExtension", "WithTwoSecurity")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "WithTwoSecurity")
		value, opError := controller.WithTwoSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "WithTwoSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithTwoSecurity'",
				Status:     statusCode,
				Instance:   "/controller/error/WithTwoSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "WithTwoSecurity")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "WithTwoSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "WithTwoSecurity")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "WithTwoSecurity")
	})
	engine.Get(toChiUrl("/e2e/with-two-security-same-method"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "WithTwoSecuritySameMethod")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"other",
							},
						},
					},
				},
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"write",
								"read",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "WithTwoSecuritySameMethod")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("x-test-scopes")
		_, isheaderParamExists := req.Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithTwoSecuritySameMethod", fieldName)
			w.Header().Set("x-RunValidatorExtension", "WithTwoSecuritySameMethod")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "WithTwoSecuritySameMethod")
		value, opError := controller.WithTwoSecuritySameMethod(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "WithTwoSecuritySameMethod")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithTwoSecuritySameMethod'",
				Status:     statusCode,
				Instance:   "/controller/error/WithTwoSecuritySameMethod",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "WithTwoSecuritySameMethod")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "WithTwoSecuritySameMethod")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "WithTwoSecuritySameMethod")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "WithTwoSecuritySameMethod")
	})
	engine.Get(toChiUrl("/e2e/default-error"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "DefaultError")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "DefaultError")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "DefaultError")
		opError := controller.DefaultError()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "DefaultError")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'DefaultError'",
				Status:     statusCode,
				Instance:   "/controller/error/DefaultError",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "DefaultError")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "DefaultError")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "DefaultError")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "DefaultError")
	})
	engine.Get(toChiUrl("/e2e/default-error-with-payload"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "DefaultErrorWithPayload")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "DefaultErrorWithPayload")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "DefaultErrorWithPayload")
		value, opError := controller.DefaultErrorWithPayload()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "DefaultErrorWithPayload")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'DefaultErrorWithPayload'",
				Status:     statusCode,
				Instance:   "/controller/error/DefaultErrorWithPayload",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "DefaultErrorWithPayload")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "DefaultErrorWithPayload")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "DefaultErrorWithPayload")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "DefaultErrorWithPayload")
	})
	engine.Get(toChiUrl("/e2e/custom-error"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "CustomError")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "CustomError")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "CustomError")
		opError := controller.CustomError()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "CustomError")
		statusCode := getStatusCode(&controller, false, opError)
		emptyErr := Response6CustomError.CustomError{}
		if opError != emptyErr {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(opError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "CustomError")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "CustomError")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "CustomError")
	})
	engine.Get(toChiUrl("/e2e/custom-error-ptr"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "CustomPtrError")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "CustomPtrError")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "CustomPtrError")
		opError := controller.CustomPtrError()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "CustomPtrError")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(opError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "CustomPtrError")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "CustomPtrError")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "CustomPtrError")
	})
	engine.Get(toChiUrl("/e2e/503-error-code"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "Error503")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "Error503")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "Error503")
		opError := controller.Error503()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "Error503")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Error503'",
				Status:     statusCode,
				Instance:   "/controller/error/Error503",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "Error503")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "Error503")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "Error503")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "Error503")
	})
	engine.Get(toChiUrl("/e2e/custom-error-503"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "CustomError503")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "CustomError503")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "CustomError503")
		opError := controller.CustomError503()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "CustomError503")
		statusCode := getStatusCode(&controller, false, opError)
		emptyErr := Response6CustomError.CustomError{}
		if opError != emptyErr {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(opError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "CustomError503")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "CustomError503")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "CustomError503")
	})
	engine.Get(toChiUrl("/e2e/context-access"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "ContextAccess")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ContextAccess")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "ContextAccess")
		opError := controller.ContextAccess()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "ContextAccess")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ContextAccess'",
				Status:     statusCode,
				Instance:   "/controller/error/ContextAccess",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "ContextAccess")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "ContextAccess")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "ContextAccess")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "ContextAccess")
	})
	engine.Get(toChiUrl("/e2e/http-method"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "Get")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "Get")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "Get")
		opError := controller.Get()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "Get")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Get'",
				Status:     statusCode,
				Instance:   "/controller/error/Get",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "Get")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "Get")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "Get")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "Get")
	})
	engine.Post(toChiUrl("/e2e/http-method"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "Post")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "Post")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "Post")
		opError := controller.Post()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "Post")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Post'",
				Status:     statusCode,
				Instance:   "/controller/error/Post",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "Post")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "Post")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "Post")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "Post")
	})
	engine.Put(toChiUrl("/e2e/http-method"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "Put")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "Put")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "Put")
		opError := controller.Put()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "Put")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Put'",
				Status:     statusCode,
				Instance:   "/controller/error/Put",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "Put")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "Put")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "Put")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "Put")
	})
	engine.Delete(toChiUrl("/e2e/http-method"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "Delete")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "Delete")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "Delete")
		opError := controller.Delete()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "Delete")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Delete'",
				Status:     statusCode,
				Instance:   "/controller/error/Delete",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "Delete")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "Delete")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "Delete")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "Delete")
	})
	engine.Patch(toChiUrl("/e2e/http-method"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "Patch")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "Patch")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "Patch")
		opError := controller.Patch()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "Patch")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Patch'",
				Status:     statusCode,
				Instance:   "/controller/error/Patch",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "Patch")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "Patch")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "Patch")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "Patch")
	})
	engine.Get(toChiUrl("/e2e/template-context-1"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "TemplateContext1")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TemplateContext1")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "TemplateContext1")
		value, opError := controller.TemplateContext1()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "TemplateContext1")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TemplateContext1'",
				Status:     statusCode,
				Instance:   "/controller/error/TemplateContext1",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "TemplateContext1")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "TemplateContext1")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "TemplateContext1")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "TemplateContext1")
		w.Header().Set("x-level", "high")
	})
	engine.Get(toChiUrl("/e2e/template-context-2"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "TemplateContext2")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TemplateContext2")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "TemplateContext2")
		value, opError := controller.TemplateContext2()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "TemplateContext2")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TemplateContext2'",
				Status:     statusCode,
				Instance:   "/controller/error/TemplateContext2",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "TemplateContext2")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "TemplateContext2")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "TemplateContext2")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "TemplateContext2")
		w.Header().Set("x-mode", "100")
		w.Header().Set("x-level", "low")
	})
	engine.Post(toChiUrl("/e2e/form"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "TestForm")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestForm")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		req.ParseForm()
		var item1RawPtr *string = nil
		item1RawArr, isitem1Exists := req.PostForm["item1"]
		item1Raw := ""
		if isitem1Exists {
			item1Raw = item1RawArr[0] // Get first value since form values are slices
		}
		if isitem1Exists {
			item1 := item1Raw
			item1RawPtr = &item1
		}
		if validatorErr := validatorInstance.Var(item1RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "item1"
			validationError := wrapValidatorError(validatorErr, "TestForm", fieldName)
			w.Header().Set("x-RunValidatorExtension", "TestForm")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		req.ParseForm()
		var item2RawPtr *string = nil
		item2RawArr, isitem2Exists := req.PostForm["item2"]
		item2Raw := ""
		if isitem2Exists {
			item2Raw = item2RawArr[0] // Get first value since form values are slices
		}
		if isitem2Exists {
			item2 := item2Raw
			item2RawPtr = &item2
		}
		if validatorErr := validatorInstance.Var(item2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "item2"
			validationError := wrapValidatorError(validatorErr, "TestForm", fieldName)
			w.Header().Set("x-RunValidatorExtension", "TestForm")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "TestForm")
		value, opError := controller.TestForm(*item1RawPtr, *item2RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "TestForm")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestForm'",
				Status:     statusCode,
				Instance:   "/controller/error/TestForm",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "TestForm")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "TestForm")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "TestForm")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "TestForm")
	})
	engine.Post(toChiUrl("/e2e/test-response-validation"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "TestResponseValidation")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestResponseValidation")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "TestResponseValidation")
		value, opError := controller.TestResponseValidation()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "TestResponseValidation")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidation'",
				Status:     statusCode,
				Instance:   "/controller/error/TestResponseValidation",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "TestResponseValidation")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "TestResponseValidation")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidation'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/TestResponseValidation",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "TestResponseValidation")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "TestResponseValidation")
	})
	engine.Post(toChiUrl("/e2e/test-response-validation-ptr"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "TestResponseValidationPtr")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestResponseValidationPtr")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "TestResponseValidationPtr")
		value, opError := controller.TestResponseValidationPtr()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "TestResponseValidationPtr")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationPtr'",
				Status:     statusCode,
				Instance:   "/controller/error/TestResponseValidationPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "TestResponseValidationPtr")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "TestResponseValidationPtr")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationPtr'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/TestResponseValidationPtr",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "TestResponseValidationPtr")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "TestResponseValidationPtr")
	})
	engine.Post(toChiUrl("/e2e/test-response-validation-null"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "TestResponseValidationNull")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestResponseValidationNull")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "TestResponseValidationNull")
		value, opError := controller.TestResponseValidationNull()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "TestResponseValidationNull")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationNull'",
				Status:     statusCode,
				Instance:   "/controller/error/TestResponseValidationNull",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "TestResponseValidationNull")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "TestResponseValidationNull")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationNull'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/TestResponseValidationNull",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "TestResponseValidationNull")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "TestResponseValidationNull")
	})
	engine.Post(toChiUrl("/e2e/test-primitive-conversions"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "TestPrimitiveConversions")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestPrimitiveConversions")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var value1RawPtr *int64 = nil
		value1Raw := req.URL.Query().Get("value1")
		isvalue1Exists := req.URL.Query().Has("value1")
		if isvalue1Exists {
			value1Uint64, conversionErr := strconv.ParseInt(value1Raw, 10, 64)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestPrimitiveConversions' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value1",
						"int64",
						reflect.TypeOf(value1Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestPrimitiveConversions",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "TestPrimitiveConversions")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			value1 := int64(value1Uint64)
			value1RawPtr = &value1
		}
		if validatorErr := validatorInstance.Var(value1RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value1"
			validationError := wrapValidatorError(validatorErr, "TestPrimitiveConversions", fieldName)
			w.Header().Set("x-RunValidatorExtension", "TestPrimitiveConversions")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var value2RawPtr *bool = nil
		value2Raw := req.URL.Query().Get("value2")
		isvalue2Exists := req.URL.Query().Has("value2")
		if isvalue2Exists {
			value2, conversionErr := strconv.ParseBool(value2Raw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestPrimitiveConversions' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value2",
						"bool",
						reflect.TypeOf(value2Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestPrimitiveConversions",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "TestPrimitiveConversions")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			value2RawPtr = &value2
		}
		if validatorErr := validatorInstance.Var(value2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value2"
			validationError := wrapValidatorError(validatorErr, "TestPrimitiveConversions", fieldName)
			w.Header().Set("x-RunValidatorExtension", "TestPrimitiveConversions")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var value3RawPtr *int = nil
		value3Raw := req.URL.Query().Get("value3")
		isvalue3Exists := req.URL.Query().Has("value3")
		if isvalue3Exists {
			value3Uint64, conversionErr := strconv.Atoi(value3Raw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestPrimitiveConversions' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value3",
						"int",
						reflect.TypeOf(value3Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestPrimitiveConversions",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "TestPrimitiveConversions")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			value3 := int(value3Uint64)
			value3RawPtr = &value3
		}
		if validatorErr := validatorInstance.Var(value3RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value3"
			validationError := wrapValidatorError(validatorErr, "TestPrimitiveConversions", fieldName)
			w.Header().Set("x-RunValidatorExtension", "TestPrimitiveConversions")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var value4RawPtr *float64 = nil
		value4Raw := req.URL.Query().Get("value4")
		isvalue4Exists := req.URL.Query().Has("value4")
		if isvalue4Exists {
			value4, conversionErr := strconv.ParseFloat(value4Raw, 64)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestPrimitiveConversions' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value4",
						"float64",
						reflect.TypeOf(value4Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestPrimitiveConversions",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "TestPrimitiveConversions")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			value4RawPtr = &value4
		}
		if validatorErr := validatorInstance.Var(value4RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value4"
			validationError := wrapValidatorError(validatorErr, "TestPrimitiveConversions", fieldName)
			w.Header().Set("x-RunValidatorExtension", "TestPrimitiveConversions")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "TestPrimitiveConversions")
		value, opError := controller.TestPrimitiveConversions(*value1RawPtr, *value2RawPtr, *value3RawPtr, *value4RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "TestPrimitiveConversions")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestPrimitiveConversions'",
				Status:     statusCode,
				Instance:   "/controller/error/TestPrimitiveConversions",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "TestPrimitiveConversions")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "TestPrimitiveConversions")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "TestPrimitiveConversions")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "TestPrimitiveConversions")
	})
	engine.Post(toChiUrl("/e2e/test-enums"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "TestEnums")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestEnums")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var value1RawPtr *Param12value1.StatusEnumeration = nil
		value1Raw := req.URL.Query().Get("value1")
		isvalue1Exists := req.URL.Query().Has("value1")
		if isvalue1Exists {
			value1 := value1Raw
			switch value1Raw {
			case "active", "inactive":
				value1Var := Param12value1.StatusEnumeration(value1)
				value1RawPtr = &value1Var
			default:
				conversionErr := fmt.Errorf("value1 must be one of \"active, inactive\" options only but got \"%s\"", value1Raw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnums' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value1",
						"StatusEnumeration",
						reflect.TypeOf(value1Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestEnums",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnums")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
		}
		if validatorErr := validatorInstance.Var(value1RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value1"
			validationError := wrapValidatorError(validatorErr, "TestEnums", fieldName)
			w.Header().Set("x-RunValidatorExtension", "TestEnums")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var value2RawPtr *Param4value2.NumberEnumeration = nil
		value2Raw := req.URL.Query().Get("value2")
		isvalue2Exists := req.URL.Query().Has("value2")
		if isvalue2Exists {
			value2Uint64, conversionErr := strconv.Atoi(value2Raw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnums' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value2",
						"NumberEnumeration",
						reflect.TypeOf(value2Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestEnums",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnums")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			value2 := int(value2Uint64)
			switch value2Raw {
			case "1", "2":
				value2Var := Param4value2.NumberEnumeration(value2)
				value2RawPtr = &value2Var
			default:
				conversionErr := fmt.Errorf("value2 must be one of \"1, 2\" options only but got \"%s\"", value2Raw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnums' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value2",
						"NumberEnumeration",
						reflect.TypeOf(value2Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestEnums",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnums")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
		}
		if validatorErr := validatorInstance.Var(value2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value2"
			validationError := wrapValidatorError(validatorErr, "TestEnums", fieldName)
			w.Header().Set("x-RunValidatorExtension", "TestEnums")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var value3RawPtr *Param11value3.ObjectWithEnum = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &value3RawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'TestEnums' but body parameter '%s' did not pass validation of '%s' - %s",
					"value3",
					"ObjectWithEnum",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/TestEnums",
			}
			w.Header().Set("x-JsonBodyValidationErrorResponseExtension", "TestEnums")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "TestEnums")
		value, opError := controller.TestEnums(*value1RawPtr, *value2RawPtr, *value3RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "TestEnums")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestEnums'",
				Status:     statusCode,
				Instance:   "/controller/error/TestEnums",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "TestEnums")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "TestEnums")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'TestEnums'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/TestEnums",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "TestEnums")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "TestEnums")
	})
	engine.Post(toChiUrl("/e2e/test-enums-in-all/{value1}"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "TestEnumsInAll")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestEnumsInAll")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var value1RawPtr *Param12value1.StatusEnumeration = nil
		value1Raw := chi.URLParam(req, "value1")
		isvalue1Exists := true // if parameter is in route but not provided, it won't reach this handler
		if isvalue1Exists {
			value1 := value1Raw
			switch value1Raw {
			case "active", "inactive":
				value1Var := Param12value1.StatusEnumeration(value1)
				value1RawPtr = &value1Var
			default:
				conversionErr := fmt.Errorf("value1 must be one of \"active, inactive\" options only but got \"%s\"", value1Raw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnumsInAll' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value1",
						"StatusEnumeration",
						reflect.TypeOf(value1Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestEnumsInAll",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnumsInAll")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
		}
		if validatorErr := validatorInstance.Var(value1RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value1"
			validationError := wrapValidatorError(validatorErr, "TestEnumsInAll", fieldName)
			w.Header().Set("x-RunValidatorExtension", "TestEnumsInAll")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var value2RawPtr *Param4value2.NumberEnumeration = nil
		value2Raw := req.Header.Get("value2")
		_, isvalue2Exists := req.Header["value2"]
		if !isvalue2Exists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("value2")
			isvalue2Exists = len(headerValues) > 0
		}
		if isvalue2Exists {
			value2Uint64, conversionErr := strconv.Atoi(value2Raw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnumsInAll' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value2",
						"NumberEnumeration",
						reflect.TypeOf(value2Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestEnumsInAll",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnumsInAll")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			value2 := int(value2Uint64)
			switch value2Raw {
			case "1", "2":
				value2Var := Param4value2.NumberEnumeration(value2)
				value2RawPtr = &value2Var
			default:
				conversionErr := fmt.Errorf("value2 must be one of \"1, 2\" options only but got \"%s\"", value2Raw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnumsInAll' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value2",
						"NumberEnumeration",
						reflect.TypeOf(value2Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestEnumsInAll",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnumsInAll")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
		}
		if validatorErr := validatorInstance.Var(value2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value2"
			validationError := wrapValidatorError(validatorErr, "TestEnumsInAll", fieldName)
			w.Header().Set("x-RunValidatorExtension", "TestEnumsInAll")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		req.ParseForm()
		var value3RawPtr *Param12value3.StatusEnumeration = nil
		value3RawArr, isvalue3Exists := req.PostForm["value3"]
		value3Raw := ""
		if isvalue3Exists {
			value3Raw = value3RawArr[0] // Get first value since form values are slices
		}
		if isvalue3Exists {
			value3 := value3Raw
			switch value3Raw {
			case "active", "inactive":
				value3Var := Param12value3.StatusEnumeration(value3)
				value3RawPtr = &value3Var
			default:
				conversionErr := fmt.Errorf("value3 must be one of \"active, inactive\" options only but got \"%s\"", value3Raw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnumsInAll' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value3",
						"StatusEnumeration",
						reflect.TypeOf(value3Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestEnumsInAll",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnumsInAll")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
		}
		if validatorErr := validatorInstance.Var(value3RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value3"
			validationError := wrapValidatorError(validatorErr, "TestEnumsInAll", fieldName)
			w.Header().Set("x-RunValidatorExtension", "TestEnumsInAll")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "TestEnumsInAll")
		value, opError := controller.TestEnumsInAll(*value1RawPtr, *value2RawPtr, *value3RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "TestEnumsInAll")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestEnumsInAll'",
				Status:     statusCode,
				Instance:   "/controller/error/TestEnumsInAll",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "TestEnumsInAll")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "TestEnumsInAll")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "TestEnumsInAll")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "TestEnumsInAll")
	})
	engine.Post(toChiUrl("/e2e/test-enums-optional"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "TestEnumsOptional")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestEnumsOptional")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var value1RawPtr *Param12value1.StatusEnumeration = nil
		value1Raw := req.Header.Get("value1")
		_, isvalue1Exists := req.Header["value1"]
		if !isvalue1Exists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("value1")
			isvalue1Exists = len(headerValues) > 0
		}
		if isvalue1Exists {
			value1 := value1Raw
			switch value1Raw {
			case "active", "inactive":
				value1Var := Param12value1.StatusEnumeration(value1)
				value1RawPtr = &value1Var
			default:
				conversionErr := fmt.Errorf("value1 must be one of \"active, inactive\" options only but got \"%s\"", value1Raw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnumsOptional' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value1",
						"StatusEnumeration",
						reflect.TypeOf(value1Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestEnumsOptional",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "TestEnumsOptional")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "TestEnumsOptional")
		value, opError := controller.TestEnumsOptional(value1RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "TestEnumsOptional")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestEnumsOptional'",
				Status:     statusCode,
				Instance:   "/controller/error/TestEnumsOptional",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "TestEnumsOptional")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "TestEnumsOptional")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "TestEnumsOptional")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "TestEnumsOptional")
	})
	engine.Post(toChiUrl("/e2e/external-packages"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "ExternalPackages")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ExternalPackages")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var unitRawPtr *Param14unit.LengthUnits = nil
		unitRaw := req.URL.Query().Get("unit")
		isunitExists := req.URL.Query().Has("unit")
		if isunitExists {
			unit := unitRaw
			switch unitRaw {
			case "Angstrom", "AstronomicalUnit", "Centimeter", "Chain", "DataMile", "Decameter", "Decimeter", "DtpPica", "DtpPoint", "Fathom", "Femtometer", "Foot", "Gigameter", "Hand", "Hectometer", "Inch", "Kilofoot", "KilolightYear", "Kilometer", "Kiloparsec", "Kiloyard", "LightYear", "MegalightYear", "Megameter", "Megaparsec", "Meter", "Microinch", "Micrometer", "Mil", "Mile", "Millimeter", "Nanometer", "NauticalMile", "Parsec", "Picometer", "PrinterPica", "PrinterPoint", "Shackle", "SolarRadius", "Twip", "UsSurveyFoot", "Yard":
				unitVar := Param14unit.LengthUnits(unit)
				unitRawPtr = &unitVar
			default:
				conversionErr := fmt.Errorf("unit must be one of \"Angstrom, AstronomicalUnit, Centimeter, Chain, DataMile, Decameter, Decimeter, DtpPica, DtpPoint, Fathom, Femtometer, Foot, Gigameter, Hand, Hectometer, Inch, Kilofoot, KilolightYear, Kilometer, Kiloparsec, Kiloyard, LightYear, MegalightYear, Megameter, Megaparsec, Meter, Microinch, Micrometer, Mil, Mile, Millimeter, Nanometer, NauticalMile, Parsec, Picometer, PrinterPica, PrinterPoint, Shackle, SolarRadius, Twip, UsSurveyFoot, Yard\" options only but got \"%s\"", unitRaw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'ExternalPackages' but parameter '%s' was not properly sent - Expected %s but got %s",
						"unit",
						"LengthUnits",
						reflect.TypeOf(unitRaw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/ExternalPackages",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "ExternalPackages")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
		}
		var dataRawPtr *Param13data.LengthDto = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ExternalPackages' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"LengthDto",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ExternalPackages",
			}
			w.Header().Set("x-JsonBodyValidationErrorResponseExtension", "ExternalPackages")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "ExternalPackages")
		value, opError := controller.ExternalPackages(unitRawPtr, *dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "ExternalPackages")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ExternalPackages'",
				Status:     statusCode,
				Instance:   "/controller/error/ExternalPackages",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "ExternalPackages")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "ExternalPackages")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'ExternalPackages'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/ExternalPackages",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "ExternalPackages")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "ExternalPackages")
	})
	engine.Post(toChiUrl("/e2e/external-packages-unique-in-struct"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "ExternalPackagesUniqueInStruct")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ExternalPackagesUniqueInStruct")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *Param15data.UniqueExternalUsage = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ExternalPackagesUniqueInStruct' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"UniqueExternalUsage",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ExternalPackagesUniqueInStruct",
			}
			w.Header().Set("x-JsonBodyValidationErrorResponseExtension", "ExternalPackagesUniqueInStruct")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "ExternalPackagesUniqueInStruct")
		value, opError := controller.ExternalPackagesUniqueInStruct(*dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "ExternalPackagesUniqueInStruct")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ExternalPackagesUniqueInStruct'",
				Status:     statusCode,
				Instance:   "/controller/error/ExternalPackagesUniqueInStruct",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "ExternalPackagesUniqueInStruct")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "ExternalPackagesUniqueInStruct")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "ExternalPackagesUniqueInStruct")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "ExternalPackagesUniqueInStruct")
	})
	engine.Post(toChiUrl("/e2e/external-packages-validation"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "ExternalPackagesValidation")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ExternalPackagesValidation")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var unitRawPtr *Param14unit.LengthUnits = nil
		unitRaw := req.URL.Query().Get("unit")
		isunitExists := req.URL.Query().Has("unit")
		if isunitExists {
			unit := unitRaw
			switch unitRaw {
			case "Angstrom", "AstronomicalUnit", "Centimeter", "Chain", "DataMile", "Decameter", "Decimeter", "DtpPica", "DtpPoint", "Fathom", "Femtometer", "Foot", "Gigameter", "Hand", "Hectometer", "Inch", "Kilofoot", "KilolightYear", "Kilometer", "Kiloparsec", "Kiloyard", "LightYear", "MegalightYear", "Megameter", "Megaparsec", "Meter", "Microinch", "Micrometer", "Mil", "Mile", "Millimeter", "Nanometer", "NauticalMile", "Parsec", "Picometer", "PrinterPica", "PrinterPoint", "Shackle", "SolarRadius", "Twip", "UsSurveyFoot", "Yard":
				unitVar := Param14unit.LengthUnits(unit)
				unitRawPtr = &unitVar
			default:
				conversionErr := fmt.Errorf("unit must be one of \"Angstrom, AstronomicalUnit, Centimeter, Chain, DataMile, Decameter, Decimeter, DtpPica, DtpPoint, Fathom, Femtometer, Foot, Gigameter, Hand, Hectometer, Inch, Kilofoot, KilolightYear, Kilometer, Kiloparsec, Kiloyard, LightYear, MegalightYear, Megameter, Megaparsec, Meter, Microinch, Micrometer, Mil, Mile, Millimeter, Nanometer, NauticalMile, Parsec, Picometer, PrinterPica, PrinterPoint, Shackle, SolarRadius, Twip, UsSurveyFoot, Yard\" options only but got \"%s\"", unitRaw)
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'ExternalPackagesValidation' but parameter '%s' was not properly sent - Expected %s but got %s",
						"unit",
						"LengthUnits",
						reflect.TypeOf(unitRaw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/ExternalPackagesValidation",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				w.Header().Set("x-ParamsValidationErrorResponseExtension", "ExternalPackagesValidation")
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
		}
		var dataRawPtr *Param16data.LengthDtoWithValidation = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ExternalPackagesValidation' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"LengthDtoWithValidation",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ExternalPackagesValidation",
			}
			w.Header().Set("x-JsonBodyValidationErrorResponseExtension", "ExternalPackagesValidation")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "ExternalPackagesValidation")
		value, opError := controller.ExternalPackagesValidation(unitRawPtr, *dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "ExternalPackagesValidation")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ExternalPackagesValidation'",
				Status:     statusCode,
				Instance:   "/controller/error/ExternalPackagesValidation",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "ExternalPackagesValidation")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "ExternalPackagesValidation")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'ExternalPackagesValidation'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/ExternalPackagesValidation",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "ExternalPackagesValidation")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "ExternalPackagesValidation")
	})
	engine.Post(toChiUrl("/e2e/arrays-in-body-and-res"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "ArraysInBodyAndRes")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ArraysInBodyAndRes")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *[]Param13data.LengthDto = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ArraysInBodyAndRes' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"[]LengthDto",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ArraysInBodyAndRes",
			}
			w.Header().Set("x-JsonBodyValidationErrorResponseExtension", "ArraysInBodyAndRes")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "ArraysInBodyAndRes")
		value, opError := controller.ArraysInBodyAndRes(*dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "ArraysInBodyAndRes")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ArraysInBodyAndRes'",
				Status:     statusCode,
				Instance:   "/controller/error/ArraysInBodyAndRes",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "ArraysInBodyAndRes")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "ArraysInBodyAndRes")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'ArraysInBodyAndRes'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/ArraysInBodyAndRes",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "ArraysInBodyAndRes")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "ArraysInBodyAndRes")
	})
	engine.Post(toChiUrl("/e2e/arrays-inside-body-and-res"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "ArraysInsideBodyAndRes")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ArraysInsideBodyAndRes")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *[]Param17data.BlaBla = nil
		conversionErr = bindAndValidateBody(req, "application/json", "", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ArraysInsideBodyAndRes' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"[]BlaBla",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ArraysInsideBodyAndRes",
			}
			w.Header().Set("x-JsonBodyValidationErrorResponseExtension", "ArraysInsideBodyAndRes")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "ArraysInsideBodyAndRes")
		value, opError := controller.ArraysInsideBodyAndRes(dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "ArraysInsideBodyAndRes")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ArraysInsideBodyAndRes'",
				Status:     statusCode,
				Instance:   "/controller/error/ArraysInsideBodyAndRes",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "ArraysInsideBodyAndRes")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "ArraysInsideBodyAndRes")
		var outputValidationErr error
		if value == nil {
			outputValidationErr = fmt.Errorf("Response payload is nil")
		} else {
			outputValidationErr = validateDataRecursive(value, "")
		}
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'ArraysInsideBodyAndRes'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/ArraysInsideBodyAndRes",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "ArraysInsideBodyAndRes")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "ArraysInsideBodyAndRes")
	})
	engine.Post(toChiUrl("/e2e/deep-arrays-with-validation"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "DeepArraysWithValidation")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "DeepArraysWithValidation")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *[][]Param18data.BlaBla2 = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'DeepArraysWithValidation' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"[][]BlaBla2",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/DeepArraysWithValidation",
			}
			w.Header().Set("x-JsonBodyValidationErrorResponseExtension", "DeepArraysWithValidation")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "DeepArraysWithValidation")
		value, opError := controller.DeepArraysWithValidation(*dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "DeepArraysWithValidation")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'DeepArraysWithValidation'",
				Status:     statusCode,
				Instance:   "/controller/error/DeepArraysWithValidation",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "DeepArraysWithValidation")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "DeepArraysWithValidation")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'DeepArraysWithValidation'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/DeepArraysWithValidation",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "DeepArraysWithValidation")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "DeepArraysWithValidation")
	})
	engine.Post(toChiUrl("/e2e/embedded-structs"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "EmbeddedStructs")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "EmbeddedStructs")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *Param19data.TheModel = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'EmbeddedStructs' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"TheModel",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/EmbeddedStructs",
			}
			w.Header().Set("x-JsonBodyValidationErrorResponseExtension", "EmbeddedStructs")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "EmbeddedStructs")
		value, opError := controller.EmbeddedStructs(*dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "EmbeddedStructs")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'EmbeddedStructs'",
				Status:     statusCode,
				Instance:   "/controller/error/EmbeddedStructs",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "EmbeddedStructs")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "EmbeddedStructs")
		var outputValidationErr error
		outputValidationErr = validateDataRecursive(value, "")
		if outputValidationErr != nil {
			// Middlewares onOutputValidationMiddlewares section
			for _, middleware := range onOutputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, outputValidationErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onOutputValidationMiddlewares section
			outputValidationStatusCode := http.StatusInternalServerError
			outputValidationRfc7807Error := runtime.Rfc7807Error{
				Type:       http.StatusText(outputValidationStatusCode),
				Detail:     "Encountered an error during operation 'EmbeddedStructs'",
				Status:     outputValidationStatusCode,
				Instance:   "/controller/error/EmbeddedStructs",
				Extensions: map[string]string{},
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(outputValidationStatusCode)
			json.NewEncoder(w).Encode(outputValidationRfc7807Error)
			return
		}
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "EmbeddedStructs")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "EmbeddedStructs")
	})
	engine.Post(toChiUrl("/e2e/structs-with-inner-pointer"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "StructsWithInnerPointer")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "StructsWithInnerPointer")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *Param20data.TheModelWithInnerPointer = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'StructsWithInnerPointer' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"TheModelWithInnerPointer",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/StructsWithInnerPointer",
			}
			w.Header().Set("x-JsonBodyValidationErrorResponseExtension", "StructsWithInnerPointer")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "StructsWithInnerPointer")
		value, opError := controller.StructsWithInnerPointer(*dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "StructsWithInnerPointer")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'StructsWithInnerPointer'",
				Status:     statusCode,
				Instance:   "/controller/error/StructsWithInnerPointer",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "StructsWithInnerPointer")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "StructsWithInnerPointer")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "StructsWithInnerPointer")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "StructsWithInnerPointer")
	})
	engine.Post(toChiUrl("/e2e/context-injection-empty"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "ContextInjectionEmpty")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ContextInjectionEmpty")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "ContextInjectionEmpty")
		opError := controller.ContextInjectionEmpty(getRequestContext(req))
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "ContextInjectionEmpty")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ContextInjectionEmpty'",
				Status:     statusCode,
				Instance:   "/controller/error/ContextInjectionEmpty",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "ContextInjectionEmpty")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "ContextInjectionEmpty")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "ContextInjectionEmpty")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "ContextInjectionEmpty")
	})
	engine.Post(toChiUrl("/e2e/context-injection"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "ContextInjection")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ContextInjection")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *Param19data.TheModel = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ContextInjection' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"TheModel",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ContextInjection",
			}
			w.Header().Set("x-JsonBodyValidationErrorResponseExtension", "ContextInjection")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "ContextInjection")
		opError := controller.ContextInjection(getRequestContext(req), *dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "ContextInjection")
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ContextInjection'",
				Status:     statusCode,
				Instance:   "/controller/error/ContextInjection",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "ContextInjection")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "ContextInjection")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "ContextInjection")
		w.WriteHeader(statusCode)
		w.Header().Set("x-RouteEndRoutesExtension", "ContextInjection")
	})
	// E2EClassSecController
	engine.Get(toChiUrl("/e2e/with-default-class-security"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "WithDefaultClassSecurity")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"class",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "WithDefaultClassSecurity")
			return
		}
		controller := E2EClassSecController.E2EClassSecController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("x-test-scopes")
		_, isheaderParamExists := req.Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithDefaultClassSecurity", fieldName)
			w.Header().Set("x-RunValidatorExtension", "WithDefaultClassSecurity")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "WithDefaultClassSecurity")
		value, opError := controller.WithDefaultClassSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "WithDefaultClassSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithDefaultClassSecurity'",
				Status:     statusCode,
				Instance:   "/controller/error/WithDefaultClassSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "WithDefaultClassSecurity")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "WithDefaultClassSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "WithDefaultClassSecurity")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "WithDefaultClassSecurity")
	})
	engine.Get(toChiUrl("/e2e/with-default-override-class-security"), func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("x-RouteStartRoutesExtension", "WithOverrideClassSecurity")
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"method",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "WithOverrideClassSecurity")
			return
		}
		controller := E2EClassSecController.E2EClassSecController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("x-test-scopes")
		_, isheaderParamExists := req.Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithOverrideClassSecurity", fieldName)
			w.Header().Set("x-RunValidatorExtension", "WithOverrideClassSecurity")
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		w.Header().Set("x-BeforeOperationRoutesExtension", "WithOverrideClassSecurity")
		value, opError := controller.WithOverrideClassSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		w.Header().Set("x-inject", "true")
		w.Header().Set("x-ResponseHeadersExtension", "WithOverrideClassSecurity")
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithOverrideClassSecurity'",
				Status:     statusCode,
				Instance:   "/controller/error/WithOverrideClassSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			w.Header().Set("x-JsonErrorResponseExtension", "WithOverrideClassSecurity")
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		w.Header().Set("x-JsonResponseExtension", "WithOverrideClassSecurity")
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		w.Header().Set("x-AfterOperationRoutesExtension", "WithOverrideClassSecurity")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		w.Header().Set("x-RouteEndRoutesExtension", "WithOverrideClassSecurity")
	})
}
