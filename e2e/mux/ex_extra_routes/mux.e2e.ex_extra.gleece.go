/*
--
This file is automatically generated. Any manual changes to this file may be overwritten.
It includes routes and handlers by the Gleece API Routes Generator.
--
Authors: Haim Kastner & Yuval Pomerchik
Generated by: Gleece Routes Generator
Generated Date: 2025-12-13
Target Engine: Gorilla Mux (https://github.com/gorilla/mux)
--
Usage:
Refer to the Gleece documentation https://docs.gleece.dev for details on how to use the generated routes and handlers.
--
Repository: https://github.com/gopher-fleece/gleece
--
*/
package ex_extra_routes

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/go-playground/validator/v10"
	E2EClassSecController "github.com/gopher-fleece/gleece/e2e/assets"
	E2EController "github.com/gopher-fleece/gleece/e2e/assets"
	Param11value3 "github.com/gopher-fleece/gleece/e2e/assets"
	Param12value1 "github.com/gopher-fleece/gleece/e2e/assets"
	Param12value3 "github.com/gopher-fleece/gleece/e2e/assets"
	Param15data "github.com/gopher-fleece/gleece/e2e/assets"
	Param16data "github.com/gopher-fleece/gleece/e2e/assets"
	Param17data "github.com/gopher-fleece/gleece/e2e/assets"
	Param18data "github.com/gopher-fleece/gleece/e2e/assets"
	Param19data "github.com/gopher-fleece/gleece/e2e/assets"
	Param20data "github.com/gopher-fleece/gleece/e2e/assets"
	Param22arrive "github.com/gopher-fleece/gleece/e2e/assets"
	Param23arrive "github.com/gopher-fleece/gleece/e2e/assets"
	Param24object "github.com/gopher-fleece/gleece/e2e/assets"
	Param25num "github.com/gopher-fleece/gleece/e2e/assets"
	Param26str "github.com/gopher-fleece/gleece/e2e/assets"
	Param27values "github.com/gopher-fleece/gleece/e2e/assets"
	Param28values2 "github.com/gopher-fleece/gleece/e2e/assets"
	Param29values2 "github.com/gopher-fleece/gleece/e2e/assets"
	Param31values "github.com/gopher-fleece/gleece/e2e/assets"
	Param32values2 "github.com/gopher-fleece/gleece/e2e/assets"
	Param4value2 "github.com/gopher-fleece/gleece/e2e/assets"
	Param5theBody "github.com/gopher-fleece/gleece/e2e/assets"
	Response6CustomError "github.com/gopher-fleece/gleece/e2e/assets"
	RequestAuth "github.com/gopher-fleece/gleece/e2e/mux/auth"
	"github.com/gopher-fleece/runtime"
	"github.com/gorilla/mux"
	Param13data "github.com/haimkastner/unitsnet-go/units"
	Param14unit "github.com/haimkastner/unitsnet-go/units"
	"io"
	"net/http"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	// import extension placeholder
)

var validatorInstance = validator.New()
var urlParamRegex *regexp.Regexp

type SecurityListRelation string

const (
	SecurityListRelationAnd SecurityListRelation = "AND"
)

type SecurityCheckList struct {
	Checks   []runtime.SecurityCheck
	Relation SecurityListRelation
}

// type declarations extension placeholder
func getRequestContext(req *http.Request) context.Context {
	return req.Context()
}
func setRequestContext(req *http.Request, ctx context.Context) {
	if ctx != nil {
		*req = *req.WithContext(ctx)
	}
}
func registerEnumValidation(validate *validator.Validate, validationName string, allowedValues []string) {
	// Convert the array to a map for O(1) lookup
	lookup := make(map[string]struct{})
	for _, val := range allowedValues {
		lookup[val] = struct{}{}
	}
	// Register the custom validation
	validate.RegisterValidation(validationName, func(fl validator.FieldLevel) bool {
		field := fl.Field().String()
		_, exists := lookup[field]
		return exists
	})
}
func extractValidationErrorMessage(err error, fieldName *string) string {
	if err == nil {
		return ""
	}
	validationErrors, ok := err.(validator.ValidationErrors)
	if !ok {
		return err.Error()
	}
	var errStr string
	for _, validationErr := range validationErrors {
		fName := validationErr.Field()
		if fieldName != nil {
			fName = *fieldName
		}
		errStr += fmt.Sprintf("Field '%s' failed validation with tag '%s'. ", fName, validationErr.Tag())
	}
	return errStr
}
func getStatusCode(controller runtime.Controller, hasReturnValue bool, err error) int {
	if controller.GetStatus() != nil {
		return int(*controller.GetStatus())
	}
	if err != nil {
		return http.StatusInternalServerError
	}
	if hasReturnValue {
		return http.StatusOK
	}
	return http.StatusNoContent
}
func bindAndValidateBody[TOutput any](req *http.Request, contentType string, validation string, output **TOutput) error {
	var err error
	bodyBytes, err := io.ReadAll(req.Body)
	if err != nil || len(bodyBytes) == 0 {
		if strings.Contains(validation, "required") {
			return fmt.Errorf("body is required but was not provided")
		}
		return nil
	}
	var deserializedOutput TOutput
	switch contentType {
	case "application/json":
		err = json.Unmarshal(bodyBytes, &deserializedOutput)
	default:
		return fmt.Errorf("content-type %s is not currently supported by the validation subsystem", contentType)
	}
	if err != nil {
		return err
	}
	// Validate the unmarshaled data recursively
	if err = validateDataRecursive(deserializedOutput, ""); err != nil {
		return err
	}
	*output = &deserializedOutput
	return nil
}
func validateDataRecursive(data interface{}, path string) error {
	val := reflect.ValueOf(data)
	// Handle pointers by dereferencing
	if val.Kind() == reflect.Ptr {
		if val.IsNil() {
			return nil
		}
		return validateDataRecursive(val.Elem().Interface(), path)
	}
	// Handle different types
	switch val.Kind() {
	case reflect.Slice, reflect.Array:
		// For slices/arrays, validate each element recursively
		for i := 0; i < val.Len(); i++ {
			elemPath := path
			if path != "" {
				elemPath = fmt.Sprintf("%s[%d]", path, i)
			} else {
				elemPath = fmt.Sprintf("[%d]", i)
			}
			// Get the element - handle case where element might be nil
			elem := val.Index(i)
			if elem.Kind() == reflect.Ptr && elem.IsNil() {
				continue
			}
			// Validate the element recursively
			if err := validateDataRecursive(elem.Interface(), elemPath); err != nil {
				return err
			}
		}
		return nil
	case reflect.Map:
		// For maps, validate each value recursively
		for _, key := range val.MapKeys() {
			elemPath := path
			if path != "" {
				elemPath = fmt.Sprintf("%s.%v", path, key.Interface())
			} else {
				elemPath = fmt.Sprintf("%v", key.Interface())
			}
			elemVal := val.MapIndex(key)
			if elemVal.Kind() == reflect.Ptr && elemVal.IsNil() {
				continue
			}
			if err := validateDataRecursive(elemVal.Interface(), elemPath); err != nil {
				return err
			}
		}
		return nil
	case reflect.Struct:
		// Validate structs with the validator
		if err := validatorInstance.Struct(data); err != nil {
			if path != "" {
				return fmt.Errorf("validation error at %s: %w", path, err)
			}
			return err
		}
		return nil
	default:
		// Primitive types don't need validation
		return nil
	}
}
func toMuxUrl(url string) string {
	return url
}
func authorize(req *http.Request, checksLists []SecurityCheckList) *runtime.SecurityError {
	var lastError *runtime.SecurityError
	for _, list := range checksLists {
		if list.Relation != SecurityListRelationAnd {
			panic(
				"Encountered a security list relation of type '%s' - this is unexpected and indicates a bug in Gleece itself." +
					"Please open an issue at https://github.com/gopher-fleece/gleece/issues",
			)
		}
		// Iterate over each security list
		encounteredErrorInList := false
		for _, check := range list.Checks {
			secCtx, secErr := RequestAuth.GleeceRequestAuthorization(getRequestContext(req), req, check)
			setRequestContext(req, secCtx)
			if secErr != nil {
				lastError = secErr
				encounteredErrorInList = true
				break
			}
		}
		// If no error was encountered, validation is considered successful
		// otherwise, we continue over to the next iteration whilst keeping track of the last error
		if !encounteredErrorInList {
			return nil
		}
	}
	// If we got here it means authentication has failed
	return lastError
}
func handleAuthorizationError(w http.ResponseWriter, authErr *runtime.SecurityError, operationId string) {
	statusCode := int(authErr.StatusCode)
	if authErr.CustomError != nil {
		// For now, we support JSON only
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(authErr.CustomError.Payload)
		return
	}
	stdError := runtime.Rfc7807Error{
		Type:     http.StatusText(statusCode),
		Detail:   authErr.Message,
		Status:   statusCode,
		Instance: "/authorization/error/" + operationId,
	}
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(stdError)
}
func wrapValidatorError(validatorErr error, operationId string, fieldName string) runtime.Rfc7807Error {
	return runtime.Rfc7807Error{
		Type: http.StatusText(http.StatusUnprocessableEntity),
		Detail: fmt.Sprintf(
			"A request was made to operation '%s' but parameter '%s' did not pass validation - %s",
			operationId,
			fieldName,
			extractValidationErrorMessage(validatorErr, &fieldName),
		),
		Status:   http.StatusUnprocessableEntity,
		Instance: fmt.Sprintf("/validation/error/%s", operationId),
	}
}

// function declarations extension placeholder
type MiddlewareFunc func(ctx context.Context, w http.ResponseWriter, r *http.Request) (context.Context, bool)
type ErrorMiddlewareFunc func(ctx context.Context, w http.ResponseWriter, r *http.Request, err error) (context.Context, bool)

var beforeOperationMiddlewares []MiddlewareFunc
var afterOperationSuccessMiddlewares []MiddlewareFunc
var onErrorMiddlewares []ErrorMiddlewareFunc
var onInputValidationMiddlewares []ErrorMiddlewareFunc
var onOutputValidationMiddlewares []ErrorMiddlewareFunc

func RegisterMiddleware(executionType runtime.MiddlewareExecutionType, middlewareFunc MiddlewareFunc) {
	switch executionType {
	case runtime.BeforeOperation:
		beforeOperationMiddlewares = append(beforeOperationMiddlewares, middlewareFunc)
	case runtime.AfterOperationSuccess:
		afterOperationSuccessMiddlewares = append(afterOperationSuccessMiddlewares, middlewareFunc)
	}
}
func RegisterErrorMiddleware(executionType runtime.ErrorMiddlewareExecutionType, errorMiddlewareFunc ErrorMiddlewareFunc) {
	switch executionType {
	case runtime.OnInputValidationError:
		onInputValidationMiddlewares = append(onInputValidationMiddlewares, errorMiddlewareFunc)
	case runtime.OnOutputValidationError:
		onOutputValidationMiddlewares = append(onOutputValidationMiddlewares, errorMiddlewareFunc)
	case runtime.OnOperationError:
		onErrorMiddlewares = append(onErrorMiddlewares, errorMiddlewareFunc)
	}
}
func RegisterCustomValidator(validateTagName string, validateFunc runtime.ValidationFunc) {
	validatorInstance.RegisterValidation(validateTagName, func(fl validator.FieldLevel) bool {
		return validateFunc(fl)
	})
}
func RegisterRoutes(engine *mux.Router) {
	urlParamRegex = regexp.MustCompile(`\{([\w\d-_]+)\}`)
	// register routes extension placeholder
	// E2EClassSecController
	engine.HandleFunc(toMuxUrl("/e2e/with-default-class-security"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"class",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "WithDefaultClassSecurity")
			return
		}
		controller := E2EClassSecController.E2EClassSecController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("x-test-scopes")
		_, isheaderParamExists := req.Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithDefaultClassSecurity", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.WithDefaultClassSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithDefaultClassSecurity'",
				Status:     statusCode,
				Instance:   "/controller/error/WithDefaultClassSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/with-default-override-class-security"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"method",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "WithOverrideClassSecurity")
			return
		}
		controller := E2EClassSecController.E2EClassSecController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("x-test-scopes")
		_, isheaderParamExists := req.Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithOverrideClassSecurity", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.WithOverrideClassSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithOverrideClassSecurity'",
				Status:     statusCode,
				Instance:   "/controller/error/WithOverrideClassSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	// E2EController
	engine.HandleFunc(toMuxUrl("/e2e/simple-get"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGet")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.SimpleGet()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGet'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGet",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/simple-get-empty-string"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetEmptyString")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.SimpleGetEmptyString()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetEmptyString'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetEmptyString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/simple-get-ptr-string"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetPtrString")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.SimpleGetPtrString()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetPtrString'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetPtrString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/simple-get-null-string"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetNullString")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.SimpleGetNullString()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetNullString'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetNullString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/simple-get-object"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetObject")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.SimpleGetObject()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObject'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetObject",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/simple-get-object-ptr"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetObjectPtr")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.SimpleGetObjectPtr()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectPtr'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetObjectPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/simple-get-object-null"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetObjectNull")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.SimpleGetObjectNull()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetObjectNull'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetObjectNull",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/primitive-return-type"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PrimitiveReturnType")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.PrimitiveReturnType()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PrimitiveReturnType'",
				Status:     statusCode,
				Instance:   "/controller/error/PrimitiveReturnType",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/primitive-array-return-type"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PrimitiveArrayReturnType")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.PrimitiveArrayReturnType()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PrimitiveArrayReturnType'",
				Status:     statusCode,
				Instance:   "/controller/error/PrimitiveArrayReturnType",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/primitive-alias-return-type"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PrimitiveAliasReturnType")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.PrimitiveAliasReturnType()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PrimitiveAliasReturnType'",
				Status:     statusCode,
				Instance:   "/controller/error/PrimitiveAliasReturnType",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/primitive-alias-array-return-type"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PrimitiveAliasArrayReturnType")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.PrimitiveAliasArrayReturnType()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PrimitiveAliasArrayReturnType'",
				Status:     statusCode,
				Instance:   "/controller/error/PrimitiveAliasArrayReturnType",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/simple-get-empty"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "SimpleGetEmpty")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var queryParamRawPtr *string = nil
		queryParamRaw := req.URL.Query().Get("queryParam")
		isqueryParamExists := req.URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "SimpleGetEmpty", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.SimpleGetEmpty(*queryParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'SimpleGetEmpty'",
				Status:     statusCode,
				Instance:   "/controller/error/SimpleGetEmpty",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/get-with-all-params/{pathParam}"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "GetWithAllParams")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var queryParamRawPtr *string = nil
		queryParamRaw := req.URL.Query().Get("queryParam")
		isqueryParamExists := req.URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParams", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		pathParamvars := mux.Vars(req)
		var pathParamRawPtr *string = nil
		pathParamRaw, ispathParamExists := pathParamvars["pathParam"]
		if ispathParamExists {
			pathParam := pathParamRaw
			pathParamRawPtr = &pathParam
		}
		if validatorErr := validatorInstance.Var(pathParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "pathParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParams", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("headerParam")
		_, isheaderParamExists := req.Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParams", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.GetWithAllParams(*queryParamRawPtr, *pathParamRawPtr, *headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetWithAllParams'",
				Status:     statusCode,
				Instance:   "/controller/error/GetWithAllParams",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/get-with-all-params-ptr/{pathParam}"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "GetWithAllParamsPtr")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var queryParamRawPtr *string = nil
		queryParamRaw := req.URL.Query().Get("queryParam")
		isqueryParamExists := req.URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		pathParamvars := mux.Vars(req)
		var pathParamRawPtr *string = nil
		pathParamRaw, ispathParamExists := pathParamvars["pathParam"]
		if ispathParamExists {
			pathParam := pathParamRaw
			pathParamRawPtr = &pathParam
		}
		if validatorErr := validatorInstance.Var(pathParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "pathParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsPtr", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("headerParam")
		_, isheaderParamExists := req.Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.GetWithAllParamsPtr(queryParamRawPtr, pathParamRawPtr, headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetWithAllParamsPtr'",
				Status:     statusCode,
				Instance:   "/controller/error/GetWithAllParamsPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/get-with-all-params-required-ptr/{pathParam}"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "GetWithAllParamsRequiredPtr")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var queryParamRawPtr *string = nil
		queryParamRaw := req.URL.Query().Get("queryParam")
		isqueryParamExists := req.URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsRequiredPtr", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		pathParamvars := mux.Vars(req)
		var pathParamRawPtr *string = nil
		pathParamRaw, ispathParamExists := pathParamvars["pathParam"]
		if ispathParamExists {
			pathParam := pathParamRaw
			pathParamRawPtr = &pathParam
		}
		if validatorErr := validatorInstance.Var(pathParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "pathParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsRequiredPtr", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("headerParam")
		_, isheaderParamExists := req.Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "GetWithAllParamsRequiredPtr", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.GetWithAllParamsRequiredPtr(queryParamRawPtr, pathParamRawPtr, headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetWithAllParamsRequiredPtr'",
				Status:     statusCode,
				Instance:   "/controller/error/GetWithAllParamsRequiredPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/post-with-all-params-body"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PostWithAllParamsWithBody")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var queryParamRawPtr *string = nil
		queryParamRaw := req.URL.Query().Get("queryParam")
		isqueryParamExists := req.URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		if validatorErr := validatorInstance.Var(queryParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "queryParam"
			validationError := wrapValidatorError(validatorErr, "PostWithAllParamsWithBody", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("headerParam")
		_, isheaderParamExists := req.Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "PostWithAllParamsWithBody", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var theBodyRawPtr *Param5theBody.BodyInfo = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &theBodyRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'PostWithAllParamsWithBody' but body parameter '%s' did not pass validation of '%s' - %s",
					"theBody",
					"BodyInfo",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/PostWithAllParamsWithBody",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.PostWithAllParamsWithBody(*queryParamRawPtr, *headerParamRawPtr, *theBodyRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBody'",
				Status:     statusCode,
				Instance:   "/controller/error/PostWithAllParamsWithBody",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/post-with-all-params-body-ptr"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PostWithAllParamsWithBodyPtr")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var queryParamRawPtr *string = nil
		queryParamRaw := req.URL.Query().Get("queryParam")
		isqueryParamExists := req.URL.Query().Has("queryParam")
		if isqueryParamExists {
			queryParam := queryParamRaw
			queryParamRawPtr = &queryParam
		}
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("headerParam")
		_, isheaderParamExists := req.Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		var theBodyRawPtr *Param5theBody.BodyInfo = nil
		conversionErr = bindAndValidateBody(req, "application/json", "", &theBodyRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'PostWithAllParamsWithBodyPtr' but body parameter '%s' did not pass validation of '%s' - %s",
					"theBody",
					"BodyInfo",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/PostWithAllParamsWithBodyPtr",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.PostWithAllParamsWithBodyPtr(queryParamRawPtr, headerParamRawPtr, theBodyRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyPtr'",
				Status:     statusCode,
				Instance:   "/controller/error/PostWithAllParamsWithBodyPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/post-with-all-params-body-required-ptr"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "PostWithAllParamsWithBodyRequiredPtr")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var theBodyRawPtr *Param5theBody.BodyInfo = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &theBodyRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'PostWithAllParamsWithBodyRequiredPtr' but body parameter '%s' did not pass validation of '%s' - %s",
					"theBody",
					"BodyInfo",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/PostWithAllParamsWithBodyRequiredPtr",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.PostWithAllParamsWithBodyRequiredPtr(theBodyRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'PostWithAllParamsWithBodyRequiredPtr'",
				Status:     statusCode,
				Instance:   "/controller/error/PostWithAllParamsWithBodyRequiredPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/get-header-start-with-letter"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "GetHeaderStartWithLetter")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("headerParam")
		_, isheaderParamExists := req.Header["headerParam"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("headerParam")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required,validate_starts_with_letter"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "GetHeaderStartWithLetter", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.GetHeaderStartWithLetter(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'GetHeaderStartWithLetter'",
				Status:     statusCode,
				Instance:   "/controller/error/GetHeaderStartWithLetter",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/with-default-config-security"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "WithDefaultConfigSecurity")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("x-test-scopes")
		_, isheaderParamExists := req.Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithDefaultConfigSecurity", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.WithDefaultConfigSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithDefaultConfigSecurity'",
				Status:     statusCode,
				Instance:   "/controller/error/WithDefaultConfigSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/with-one-security"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"other",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "WithOneSecurity")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("x-test-scopes")
		_, isheaderParamExists := req.Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithOneSecurity", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.WithOneSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithOneSecurity'",
				Status:     statusCode,
				Instance:   "/controller/error/WithOneSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/with-two-security"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"other",
							},
						},
					},
				},
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"write",
								"read",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "WithTwoSecurity")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("x-test-scopes")
		_, isheaderParamExists := req.Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithTwoSecurity", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.WithTwoSecurity(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithTwoSecurity'",
				Status:     statusCode,
				Instance:   "/controller/error/WithTwoSecurity",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/with-two-security-same-method"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"other",
							},
						},
					},
				},
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName",
							Scopes: []string{
								"write",
								"read",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "WithTwoSecuritySameMethod")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var headerParamRawPtr *string = nil
		headerParamRaw := req.Header.Get("x-test-scopes")
		_, isheaderParamExists := req.Header["x-test-scopes"]
		if !isheaderParamExists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("x-test-scopes")
			isheaderParamExists = len(headerValues) > 0
		}
		if isheaderParamExists {
			headerParam := headerParamRaw
			headerParamRawPtr = &headerParam
		}
		if validatorErr := validatorInstance.Var(headerParamRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "headerParam"
			validationError := wrapValidatorError(validatorErr, "WithTwoSecuritySameMethod", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.WithTwoSecuritySameMethod(*headerParamRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'WithTwoSecuritySameMethod'",
				Status:     statusCode,
				Instance:   "/controller/error/WithTwoSecuritySameMethod",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/default-error"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "DefaultError")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.DefaultError()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'DefaultError'",
				Status:     statusCode,
				Instance:   "/controller/error/DefaultError",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/default-error-with-payload"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "DefaultErrorWithPayload")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.DefaultErrorWithPayload()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'DefaultErrorWithPayload'",
				Status:     statusCode,
				Instance:   "/controller/error/DefaultErrorWithPayload",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/custom-error"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "CustomError")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.CustomError()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		emptyErr := Response6CustomError.CustomError{}
		if opError != emptyErr {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(opError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/custom-error-ptr"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "CustomPtrError")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.CustomPtrError()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(opError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/503-error-code"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "Error503")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.Error503()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Error503'",
				Status:     statusCode,
				Instance:   "/controller/error/Error503",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/custom-error-503"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "CustomError503")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.CustomError503()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		emptyErr := Response6CustomError.CustomError{}
		if opError != emptyErr {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(opError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/context-access"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ContextAccess")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.ContextAccess()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ContextAccess'",
				Status:     statusCode,
				Instance:   "/controller/error/ContextAccess",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/http-method"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "Get")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.Get()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Get'",
				Status:     statusCode,
				Instance:   "/controller/error/Get",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/http-method"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "Post")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.Post()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Post'",
				Status:     statusCode,
				Instance:   "/controller/error/Post",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/http-method"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "Put")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.Put()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Put'",
				Status:     statusCode,
				Instance:   "/controller/error/Put",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("PUT")
	engine.HandleFunc(toMuxUrl("/e2e/http-method"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "Delete")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.Delete()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Delete'",
				Status:     statusCode,
				Instance:   "/controller/error/Delete",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("DELETE")
	engine.HandleFunc(toMuxUrl("/e2e/http-method"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "Patch")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.Patch()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'Patch'",
				Status:     statusCode,
				Instance:   "/controller/error/Patch",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("PATCH")
	engine.HandleFunc(toMuxUrl("/e2e/template-context-1"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TemplateContext1")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.TemplateContext1()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TemplateContext1'",
				Status:     statusCode,
				Instance:   "/controller/error/TemplateContext1",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/template-context-2"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TemplateContext2")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.TemplateContext2()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TemplateContext2'",
				Status:     statusCode,
				Instance:   "/controller/error/TemplateContext2",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("GET")
	engine.HandleFunc(toMuxUrl("/e2e/form"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestForm")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		req.ParseForm()
		var item1RawPtr *string = nil
		item1RawArr, isitem1Exists := req.PostForm["item1"]
		item1Raw := ""
		if isitem1Exists {
			item1Raw = item1RawArr[0] // Get first value since form values are slices
		}
		if isitem1Exists {
			item1 := item1Raw
			item1RawPtr = &item1
		}
		if validatorErr := validatorInstance.Var(item1RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "item1"
			validationError := wrapValidatorError(validatorErr, "TestForm", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		req.ParseForm()
		var item2RawPtr *string = nil
		item2RawArr, isitem2Exists := req.PostForm["item2"]
		item2Raw := ""
		if isitem2Exists {
			item2Raw = item2RawArr[0] // Get first value since form values are slices
		}
		if isitem2Exists {
			item2 := item2Raw
			item2RawPtr = &item2
		}
		if validatorErr := validatorInstance.Var(item2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "item2"
			validationError := wrapValidatorError(validatorErr, "TestForm", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.TestForm(*item1RawPtr, *item2RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestForm'",
				Status:     statusCode,
				Instance:   "/controller/error/TestForm",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/form-extra"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestFormExtra")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		req.ParseForm()
		var item1RawPtr *int64 = nil
		item1RawArr, isitem1Exists := req.PostForm["item1"]
		item1Raw := ""
		if isitem1Exists {
			item1Raw = item1RawArr[0] // Get first value since form values are slices
		}
		if isitem1Exists {
			item1Uint64, conversionErr := strconv.ParseInt(item1Raw, 10, 64)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestFormExtra' but parameter '%s' was not properly sent - Expected %s but got %s",
						"item1",
						"int64",
						reflect.TypeOf(item1Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestFormExtra",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				// params validation error response extension placeholder
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			item1 := int64(item1Uint64)
			item1RawPtr = &item1
		}
		if validatorErr := validatorInstance.Var(item1RawPtr, "required,gte=80"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "item1"
			validationError := wrapValidatorError(validatorErr, "TestFormExtra", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		req.ParseForm()
		var item2RawPtr *string = nil
		item2RawArr, isitem2Exists := req.PostForm["item2"]
		item2Raw := ""
		if isitem2Exists {
			item2Raw = item2RawArr[0] // Get first value since form values are slices
		}
		if isitem2Exists {
			item2 := item2Raw
			item2RawPtr = &item2
		}
		if validatorErr := validatorInstance.Var(item2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "item2"
			validationError := wrapValidatorError(validatorErr, "TestFormExtra", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var item3RawPtr *int64 = nil
		item3Raw := req.URL.Query().Get("item3")
		isitem3Exists := req.URL.Query().Has("item3")
		if isitem3Exists {
			item3Uint64, conversionErr := strconv.ParseInt(item3Raw, 10, 64)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestFormExtra' but parameter '%s' was not properly sent - Expected %s but got %s",
						"item3",
						"int64",
						reflect.TypeOf(item3Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestFormExtra",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				// params validation error response extension placeholder
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			item3 := int64(item3Uint64)
			item3RawPtr = &item3
		}
		if validatorErr := validatorInstance.Var(item3RawPtr, "required,gte=80"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "item3"
			validationError := wrapValidatorError(validatorErr, "TestFormExtra", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.TestFormExtra(*item1RawPtr, *item2RawPtr, *item3RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestFormExtra'",
				Status:     statusCode,
				Instance:   "/controller/error/TestFormExtra",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/test-response-validation"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestResponseValidation")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.TestResponseValidation()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidation'",
				Status:     statusCode,
				Instance:   "/controller/error/TestResponseValidation",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/test-response-validation-ptr"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestResponseValidationPtr")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.TestResponseValidationPtr()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationPtr'",
				Status:     statusCode,
				Instance:   "/controller/error/TestResponseValidationPtr",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/test-response-validation-null"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestResponseValidationNull")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.TestResponseValidationNull()
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestResponseValidationNull'",
				Status:     statusCode,
				Instance:   "/controller/error/TestResponseValidationNull",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/test-primitive-conversions"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestPrimitiveConversions")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var value1RawPtr *int64 = nil
		value1Raw := req.URL.Query().Get("value1")
		isvalue1Exists := req.URL.Query().Has("value1")
		if isvalue1Exists {
			value1Uint64, conversionErr := strconv.ParseInt(value1Raw, 10, 64)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestPrimitiveConversions' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value1",
						"int64",
						reflect.TypeOf(value1Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestPrimitiveConversions",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				// params validation error response extension placeholder
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			value1 := int64(value1Uint64)
			value1RawPtr = &value1
		}
		if validatorErr := validatorInstance.Var(value1RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value1"
			validationError := wrapValidatorError(validatorErr, "TestPrimitiveConversions", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var value2RawPtr *bool = nil
		value2Raw := req.URL.Query().Get("value2")
		isvalue2Exists := req.URL.Query().Has("value2")
		if isvalue2Exists {
			value2Bool, conversionErr := strconv.ParseBool(value2Raw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestPrimitiveConversions' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value2",
						"bool",
						reflect.TypeOf(value2Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestPrimitiveConversions",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				// params validation error response extension placeholder
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			value2 := value2Bool
			value2RawPtr = &value2
		}
		if validatorErr := validatorInstance.Var(value2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value2"
			validationError := wrapValidatorError(validatorErr, "TestPrimitiveConversions", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var value3RawPtr *int = nil
		value3Raw := req.URL.Query().Get("value3")
		isvalue3Exists := req.URL.Query().Has("value3")
		if isvalue3Exists {
			value3Uint64, conversionErr := strconv.Atoi(value3Raw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestPrimitiveConversions' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value3",
						"int",
						reflect.TypeOf(value3Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestPrimitiveConversions",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				// params validation error response extension placeholder
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			value3 := int(value3Uint64)
			value3RawPtr = &value3
		}
		if validatorErr := validatorInstance.Var(value3RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value3"
			validationError := wrapValidatorError(validatorErr, "TestPrimitiveConversions", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var value4RawPtr *float64 = nil
		value4Raw := req.URL.Query().Get("value4")
		isvalue4Exists := req.URL.Query().Has("value4")
		if isvalue4Exists {
			value4Float64, conversionErr := strconv.ParseFloat(value4Raw, 64)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestPrimitiveConversions' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value4",
						"float64",
						reflect.TypeOf(value4Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestPrimitiveConversions",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				// params validation error response extension placeholder
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			value4 := float64(value4Float64)
			value4RawPtr = &value4
		}
		if validatorErr := validatorInstance.Var(value4RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value4"
			validationError := wrapValidatorError(validatorErr, "TestPrimitiveConversions", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.TestPrimitiveConversions(*value1RawPtr, *value2RawPtr, *value3RawPtr, *value4RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestPrimitiveConversions'",
				Status:     statusCode,
				Instance:   "/controller/error/TestPrimitiveConversions",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/test-enums"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestEnums")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var value1RawPtr *Param12value1.StatusEnumeration = nil
		value1Raw := req.URL.Query().Get("value1")
		isvalue1Exists := req.URL.Query().Has("value1")
		if isvalue1Exists {
			value1 := value1Raw
			value1Var := Param12value1.StatusEnumeration(value1)
			value1RawPtr = &value1Var
		}
		if validatorErr := validatorInstance.Var(value1RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value1"
			validationError := wrapValidatorError(validatorErr, "TestEnums", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var value2RawPtr *Param4value2.NumberEnumeration = nil
		value2Raw := req.URL.Query().Get("value2")
		isvalue2Exists := req.URL.Query().Has("value2")
		if isvalue2Exists {
			value2Uint64, conversionErr := strconv.Atoi(value2Raw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnums' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value2",
						"NumberEnumeration",
						reflect.TypeOf(value2Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestEnums",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				// params validation error response extension placeholder
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			value2 := int(value2Uint64)
			value2Var := Param4value2.NumberEnumeration(value2)
			value2RawPtr = &value2Var
		}
		if validatorErr := validatorInstance.Var(value2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value2"
			validationError := wrapValidatorError(validatorErr, "TestEnums", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var value3RawPtr *Param11value3.ObjectWithEnum = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &value3RawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'TestEnums' but body parameter '%s' did not pass validation of '%s' - %s",
					"value3",
					"ObjectWithEnum",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/TestEnums",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.TestEnums(*value1RawPtr, *value2RawPtr, *value3RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestEnums'",
				Status:     statusCode,
				Instance:   "/controller/error/TestEnums",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/test-enums-in-all/{value1}"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestEnumsInAll")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		value1vars := mux.Vars(req)
		var value1RawPtr *Param12value1.StatusEnumeration = nil
		value1Raw, isvalue1Exists := value1vars["value1"]
		if isvalue1Exists {
			value1 := value1Raw
			value1Var := Param12value1.StatusEnumeration(value1)
			value1RawPtr = &value1Var
		}
		if validatorErr := validatorInstance.Var(value1RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value1"
			validationError := wrapValidatorError(validatorErr, "TestEnumsInAll", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var value2RawPtr *Param4value2.NumberEnumeration = nil
		value2Raw := req.Header.Get("value2")
		_, isvalue2Exists := req.Header["value2"]
		if !isvalue2Exists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("value2")
			isvalue2Exists = len(headerValues) > 0
		}
		if isvalue2Exists {
			value2Uint64, conversionErr := strconv.Atoi(value2Raw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'TestEnumsInAll' but parameter '%s' was not properly sent - Expected %s but got %s",
						"value2",
						"NumberEnumeration",
						reflect.TypeOf(value2Raw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/TestEnumsInAll",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				// params validation error response extension placeholder
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			value2 := int(value2Uint64)
			value2Var := Param4value2.NumberEnumeration(value2)
			value2RawPtr = &value2Var
		}
		if validatorErr := validatorInstance.Var(value2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value2"
			validationError := wrapValidatorError(validatorErr, "TestEnumsInAll", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		req.ParseForm()
		var value3RawPtr *Param12value3.StatusEnumeration = nil
		value3RawArr, isvalue3Exists := req.PostForm["value3"]
		value3Raw := ""
		if isvalue3Exists {
			value3Raw = value3RawArr[0] // Get first value since form values are slices
		}
		if isvalue3Exists {
			value3 := value3Raw
			value3Var := Param12value3.StatusEnumeration(value3)
			value3RawPtr = &value3Var
		}
		if validatorErr := validatorInstance.Var(value3RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "value3"
			validationError := wrapValidatorError(validatorErr, "TestEnumsInAll", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.TestEnumsInAll(*value1RawPtr, *value2RawPtr, *value3RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestEnumsInAll'",
				Status:     statusCode,
				Instance:   "/controller/error/TestEnumsInAll",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/test-enums-optional"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "TestEnumsOptional")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var value1RawPtr *Param12value1.StatusEnumeration = nil
		value1Raw := req.Header.Get("value1")
		_, isvalue1Exists := req.Header["value1"]
		if !isvalue1Exists {
			// In echo, the req..Header["key"] is not 100% reliable, so we need other check, but only if is was not found in the first method
			headerValues := req.Header.Values("value1")
			isvalue1Exists = len(headerValues) > 0
		}
		if isvalue1Exists {
			value1 := value1Raw
			value1Var := Param12value1.StatusEnumeration(value1)
			value1RawPtr = &value1Var
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.TestEnumsOptional(value1RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'TestEnumsOptional'",
				Status:     statusCode,
				Instance:   "/controller/error/TestEnumsOptional",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/external-packages"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ExternalPackages")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var unitRawPtr *Param14unit.LengthUnits = nil
		unitRaw := req.URL.Query().Get("unit")
		isunitExists := req.URL.Query().Has("unit")
		if isunitExists {
			unit := unitRaw
			unitVar := Param14unit.LengthUnits(unit)
			unitRawPtr = &unitVar
		}
		var dataRawPtr *Param13data.LengthDto = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ExternalPackages' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"LengthDto",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ExternalPackages",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.ExternalPackages(unitRawPtr, *dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ExternalPackages'",
				Status:     statusCode,
				Instance:   "/controller/error/ExternalPackages",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/external-packages-unique-in-struct"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ExternalPackagesUniqueInStruct")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *Param15data.UniqueExternalUsage = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ExternalPackagesUniqueInStruct' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"UniqueExternalUsage",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ExternalPackagesUniqueInStruct",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.ExternalPackagesUniqueInStruct(*dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ExternalPackagesUniqueInStruct'",
				Status:     statusCode,
				Instance:   "/controller/error/ExternalPackagesUniqueInStruct",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/external-packages-validation"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ExternalPackagesValidation")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var unitRawPtr *Param14unit.LengthUnits = nil
		unitRaw := req.URL.Query().Get("unit")
		isunitExists := req.URL.Query().Has("unit")
		if isunitExists {
			unit := unitRaw
			unitVar := Param14unit.LengthUnits(unit)
			unitRawPtr = &unitVar
		}
		var dataRawPtr *Param16data.LengthDtoWithValidation = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ExternalPackagesValidation' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"LengthDtoWithValidation",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ExternalPackagesValidation",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.ExternalPackagesValidation(unitRawPtr, *dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ExternalPackagesValidation'",
				Status:     statusCode,
				Instance:   "/controller/error/ExternalPackagesValidation",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/arrays-in-body-and-res"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ArraysInBodyAndRes")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *[]Param13data.LengthDto = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ArraysInBodyAndRes' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"[]LengthDto",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ArraysInBodyAndRes",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.ArraysInBodyAndRes(*dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ArraysInBodyAndRes'",
				Status:     statusCode,
				Instance:   "/controller/error/ArraysInBodyAndRes",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/arrays-inside-body-and-res"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ArraysInsideBodyAndRes")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *[]Param17data.BlaBla = nil
		conversionErr = bindAndValidateBody(req, "application/json", "", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ArraysInsideBodyAndRes' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"[]BlaBla",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ArraysInsideBodyAndRes",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.ArraysInsideBodyAndRes(dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ArraysInsideBodyAndRes'",
				Status:     statusCode,
				Instance:   "/controller/error/ArraysInsideBodyAndRes",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/deep-arrays-with-validation"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "DeepArraysWithValidation")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *[][]Param18data.BlaBla2 = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'DeepArraysWithValidation' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"[][]BlaBla2",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/DeepArraysWithValidation",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.DeepArraysWithValidation(*dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'DeepArraysWithValidation'",
				Status:     statusCode,
				Instance:   "/controller/error/DeepArraysWithValidation",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/embedded-structs"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "EmbeddedStructs")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *Param19data.TheModel = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'EmbeddedStructs' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"TheModel",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/EmbeddedStructs",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.EmbeddedStructs(*dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'EmbeddedStructs'",
				Status:     statusCode,
				Instance:   "/controller/error/EmbeddedStructs",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/structs-with-inner-pointer"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "StructsWithInnerPointer")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *Param20data.TheModelWithInnerPointer = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'StructsWithInnerPointer' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"TheModelWithInnerPointer",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/StructsWithInnerPointer",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.StructsWithInnerPointer(*dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'StructsWithInnerPointer'",
				Status:     statusCode,
				Instance:   "/controller/error/StructsWithInnerPointer",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/context-injection-empty"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ContextInjectionEmpty")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.ContextInjectionEmpty(getRequestContext(req))
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ContextInjectionEmpty'",
				Status:     statusCode,
				Instance:   "/controller/error/ContextInjectionEmpty",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/context-injection"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ContextInjection")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var dataRawPtr *Param19data.TheModel = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &dataRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ContextInjection' but body parameter '%s' did not pass validation of '%s' - %s",
					"data",
					"TheModel",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ContextInjection",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		opError := controller.ContextInjection(getRequestContext(req), *dataRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, false, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ContextInjection'",
				Status:     statusCode,
				Instance:   "/controller/error/ContextInjection",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.WriteHeader(statusCode)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/byte-slice"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ReturnsStructWithByteSlice")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var arriveRawPtr *Param22arrive.ObjectWithByteSlice = nil
		conversionErr = bindAndValidateBody(req, "application/json", "", &arriveRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ReturnsStructWithByteSlice' but body parameter '%s' did not pass validation of '%s' - %s",
					"arrive",
					"ObjectWithByteSlice",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ReturnsStructWithByteSlice",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.ReturnsStructWithByteSlice(arriveRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ReturnsStructWithByteSlice'",
				Status:     statusCode,
				Instance:   "/controller/error/ReturnsStructWithByteSlice",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/special-primitives"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "ReturnsStructWithSpecialPrimitives")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var arriveRawPtr *Param23arrive.ObjectWithSpecialPrimitives = nil
		conversionErr = bindAndValidateBody(req, "application/json", "", &arriveRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'ReturnsStructWithSpecialPrimitives' but body parameter '%s' did not pass validation of '%s' - %s",
					"arrive",
					"ObjectWithSpecialPrimitives",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/ReturnsStructWithSpecialPrimitives",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.ReturnsStructWithSpecialPrimitives(arriveRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'ReturnsStructWithSpecialPrimitives'",
				Status:     statusCode,
				Instance:   "/controller/error/ReturnsStructWithSpecialPrimitives",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/alias-of-primitive"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "AliasOfString")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var objectRawPtr *Param24object.ObjectWithAliasOfString = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &objectRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'AliasOfString' but body parameter '%s' did not pass validation of '%s' - %s",
					"object",
					"ObjectWithAliasOfString",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/AliasOfString",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var numRawPtr *Param25num.AliasOfInt = nil
		numRaw := req.URL.Query().Get("num")
		isnumExists := req.URL.Query().Has("num")
		if isnumExists {
			numUint64, conversionErr := strconv.Atoi(numRaw)
			if conversionErr != nil {
				// Middlewares onInputValidationMiddlewares section
				for _, middleware := range onInputValidationMiddlewares {
					middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
					setRequestContext(req, middlewareCtx)
					if !continueOperation {
						return
					}
				}
				// End middlewares onInputValidationMiddlewares section
				validationError := runtime.Rfc7807Error{
					Type: http.StatusText(http.StatusUnprocessableEntity),
					Detail: fmt.Sprintf(
						"A request was made to operation 'AliasOfString' but parameter '%s' was not properly sent - Expected %s but got %s",
						"num",
						"AliasOfInt",
						reflect.TypeOf(numRaw).String(),
					),
					Status:     http.StatusUnprocessableEntity,
					Instance:   "/validation/error/AliasOfString",
					Extensions: map[string]string{"error": conversionErr.Error()},
				}
				// params validation error response extension placeholder
				w.WriteHeader(http.StatusUnprocessableEntity)
				json.NewEncoder(w).Encode(validationError)
				return
			}
			num := int(numUint64)
			numVar := Param25num.AliasOfInt(num)
			numRawPtr = &numVar
		}
		if validatorErr := validatorInstance.Var(numRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "num"
			validationError := wrapValidatorError(validatorErr, "AliasOfString", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var strRawPtr *Param26str.AliasOfDirectString = nil
		strRaw := req.URL.Query().Get("str")
		isstrExists := req.URL.Query().Has("str")
		if isstrExists {
			str := strRaw
			strVar := Param26str.AliasOfDirectString(str)
			strRawPtr = &strVar
		}
		if validatorErr := validatorInstance.Var(strRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "str"
			validationError := wrapValidatorError(validatorErr, "AliasOfString", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.AliasOfString(objectRawPtr, *numRawPtr, *strRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'AliasOfString'",
				Status:     statusCode,
				Instance:   "/controller/error/AliasOfString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/body-array-of-string"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "BodyArrayOfString")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var valuesRawPtr *[]string = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &valuesRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'BodyArrayOfString' but body parameter '%s' did not pass validation of '%s' - %s",
					"values",
					"[]string",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/BodyArrayOfString",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.BodyArrayOfString(*valuesRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'BodyArrayOfString'",
				Status:     statusCode,
				Instance:   "/controller/error/BodyArrayOfString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/body-array-of-enum-string"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "BodyArrayOfStringEnum")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var conversionErr error
		var valuesRawPtr *[]Param27values.Myemamium = nil
		conversionErr = bindAndValidateBody(req, "application/json", "required", &valuesRawPtr)
		if conversionErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			validationError := runtime.Rfc7807Error{
				Type: http.StatusText(http.StatusUnprocessableEntity),
				Detail: fmt.Sprintf(
					"A request was made to operation 'BodyArrayOfStringEnum' but body parameter '%s' did not pass validation of '%s' - %s",
					"values",
					"[]Myemamium",
					extractValidationErrorMessage(conversionErr, nil),
				),
				Status:   http.StatusUnprocessableEntity,
				Instance: "/validation/error/BodyArrayOfStringEnum",
			}
			// json body validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.BodyArrayOfStringEnum(*valuesRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'BodyArrayOfStringEnum'",
				Status:     statusCode,
				Instance:   "/controller/error/BodyArrayOfStringEnum",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/query-array-of-string"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "QueryArrayOfString")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var valuesRawPtr *[]string = nil
		valuesRawArray := req.URL.Query()["values"]
		isvaluesExists := req.URL.Query().Has("values")
		if isvaluesExists {
			values := make([]string, 0, len(valuesRawArray))
			for _, valuesRaw := range valuesRawArray {
				valuesItem := valuesRaw
				values = append(values, string(valuesItem))
			}
			valuesRawPtr = &values
			valuesRawPtr = &values
		}
		if validatorErr := validatorInstance.Var(valuesRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "values"
			validationError := wrapValidatorError(validatorErr, "QueryArrayOfString", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.QueryArrayOfString(*valuesRawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'QueryArrayOfString'",
				Status:     statusCode,
				Instance:   "/controller/error/QueryArrayOfString",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/query-array-of-enum"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "QueryArrayOfEnum")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var valuesRawPtr *[]Param27values.Myemamium = nil
		valuesRawArray := req.URL.Query()["values"]
		isvaluesExists := req.URL.Query().Has("values")
		if isvaluesExists {
			values := make([]Param27values.Myemamium, 0, len(valuesRawArray))
			for _, valuesRaw := range valuesRawArray {
				valuesItem := valuesRaw
				values = append(values, Param27values.Myemamium(valuesItem))
			}
			valuesRawPtr = &values
			valuesVar := []Param27values.Myemamium(values)
			valuesRawPtr = &valuesVar
		}
		if validatorErr := validatorInstance.Var(valuesRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "values"
			validationError := wrapValidatorError(validatorErr, "QueryArrayOfEnum", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var values2RawPtr *[]Param28values2.MyaliasString = nil
		values2RawArray := req.URL.Query()["values2"]
		isvalues2Exists := req.URL.Query().Has("values2")
		if isvalues2Exists {
			values2 := make([]Param28values2.MyaliasString, 0, len(values2RawArray))
			for _, values2Raw := range values2RawArray {
				values2Item := values2Raw
				values2 = append(values2, Param28values2.MyaliasString(values2Item))
			}
			values2RawPtr = &values2
			values2Var := []Param28values2.MyaliasString(values2)
			values2RawPtr = &values2Var
		}
		if validatorErr := validatorInstance.Var(values2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "values2"
			validationError := wrapValidatorError(validatorErr, "QueryArrayOfEnum", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.QueryArrayOfEnum(*valuesRawPtr, *values2RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'QueryArrayOfEnum'",
				Status:     statusCode,
				Instance:   "/controller/error/QueryArrayOfEnum",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/query-array-of-others"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "QueryArrayOfOthers")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var valuesRawPtr *[]int = nil
		valuesRawArray := req.URL.Query()["values"]
		isvaluesExists := req.URL.Query().Has("values")
		if isvaluesExists {
			values := make([]int, 0, len(valuesRawArray))
			for _, valuesRaw := range valuesRawArray {
				valuesUint64, conversionErr := strconv.Atoi(valuesRaw)
				if conversionErr != nil {
					// Middlewares onInputValidationMiddlewares section
					for _, middleware := range onInputValidationMiddlewares {
						middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
						setRequestContext(req, middlewareCtx)
						if !continueOperation {
							return
						}
					}
					// End middlewares onInputValidationMiddlewares section
					validationError := runtime.Rfc7807Error{
						Type: http.StatusText(http.StatusUnprocessableEntity),
						Detail: fmt.Sprintf(
							"A request was made to operation 'QueryArrayOfOthers' but parameter '%s' was not properly sent - Expected %s but got %s",
							"values",
							"[]int",
							reflect.TypeOf(valuesRaw).String(),
						),
						Status:     http.StatusUnprocessableEntity,
						Instance:   "/validation/error/QueryArrayOfOthers",
						Extensions: map[string]string{"error": conversionErr.Error()},
					}
					// params validation error response extension placeholder
					w.WriteHeader(http.StatusUnprocessableEntity)
					json.NewEncoder(w).Encode(validationError)
					return
				}
				valuesItem := int(valuesUint64)
				values = append(values, int(valuesItem))
			}
			valuesRawPtr = &values
			valuesRawPtr = &values
		}
		if validatorErr := validatorInstance.Var(valuesRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "values"
			validationError := wrapValidatorError(validatorErr, "QueryArrayOfOthers", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var values2RawPtr *[]Param29values2.MyaliasInt = nil
		values2RawArray := req.URL.Query()["values2"]
		isvalues2Exists := req.URL.Query().Has("values2")
		if isvalues2Exists {
			values2 := make([]Param29values2.MyaliasInt, 0, len(values2RawArray))
			for _, values2Raw := range values2RawArray {
				values2Uint64, conversionErr := strconv.Atoi(values2Raw)
				if conversionErr != nil {
					// Middlewares onInputValidationMiddlewares section
					for _, middleware := range onInputValidationMiddlewares {
						middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
						setRequestContext(req, middlewareCtx)
						if !continueOperation {
							return
						}
					}
					// End middlewares onInputValidationMiddlewares section
					validationError := runtime.Rfc7807Error{
						Type: http.StatusText(http.StatusUnprocessableEntity),
						Detail: fmt.Sprintf(
							"A request was made to operation 'QueryArrayOfOthers' but parameter '%s' was not properly sent - Expected %s but got %s",
							"values2",
							"[]MyaliasInt",
							reflect.TypeOf(values2Raw).String(),
						),
						Status:     http.StatusUnprocessableEntity,
						Instance:   "/validation/error/QueryArrayOfOthers",
						Extensions: map[string]string{"error": conversionErr.Error()},
					}
					// params validation error response extension placeholder
					w.WriteHeader(http.StatusUnprocessableEntity)
					json.NewEncoder(w).Encode(validationError)
					return
				}
				values2Item := int(values2Uint64)
				values2 = append(values2, Param29values2.MyaliasInt(values2Item))
			}
			values2RawPtr = &values2
			values2Var := []Param29values2.MyaliasInt(values2)
			values2RawPtr = &values2Var
		}
		if validatorErr := validatorInstance.Var(values2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "values2"
			validationError := wrapValidatorError(validatorErr, "QueryArrayOfOthers", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var values3RawPtr *[]bool = nil
		values3RawArray := req.URL.Query()["values3"]
		isvalues3Exists := req.URL.Query().Has("values3")
		if isvalues3Exists {
			values3 := make([]bool, 0, len(values3RawArray))
			for _, values3Raw := range values3RawArray {
				values3Bool, conversionErr := strconv.ParseBool(values3Raw)
				if conversionErr != nil {
					// Middlewares onInputValidationMiddlewares section
					for _, middleware := range onInputValidationMiddlewares {
						middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
						setRequestContext(req, middlewareCtx)
						if !continueOperation {
							return
						}
					}
					// End middlewares onInputValidationMiddlewares section
					validationError := runtime.Rfc7807Error{
						Type: http.StatusText(http.StatusUnprocessableEntity),
						Detail: fmt.Sprintf(
							"A request was made to operation 'QueryArrayOfOthers' but parameter '%s' was not properly sent - Expected %s but got %s",
							"values3",
							"[]bool",
							reflect.TypeOf(values3Raw).String(),
						),
						Status:     http.StatusUnprocessableEntity,
						Instance:   "/validation/error/QueryArrayOfOthers",
						Extensions: map[string]string{"error": conversionErr.Error()},
					}
					// params validation error response extension placeholder
					w.WriteHeader(http.StatusUnprocessableEntity)
					json.NewEncoder(w).Encode(validationError)
					return
				}
				values3Item := values3Bool
				values3 = append(values3, bool(values3Item))
			}
			values3RawPtr = &values3
			values3RawPtr = &values3
		}
		if validatorErr := validatorInstance.Var(values3RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "values3"
			validationError := wrapValidatorError(validatorErr, "QueryArrayOfOthers", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var values4RawPtr *[]int32 = nil
		values4RawArray := req.URL.Query()["values4"]
		isvalues4Exists := req.URL.Query().Has("values4")
		if isvalues4Exists {
			values4 := make([]int32, 0, len(values4RawArray))
			for _, values4Raw := range values4RawArray {
				values4Uint64, conversionErr := strconv.ParseInt(values4Raw, 10, 32)
				if conversionErr != nil {
					// Middlewares onInputValidationMiddlewares section
					for _, middleware := range onInputValidationMiddlewares {
						middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
						setRequestContext(req, middlewareCtx)
						if !continueOperation {
							return
						}
					}
					// End middlewares onInputValidationMiddlewares section
					validationError := runtime.Rfc7807Error{
						Type: http.StatusText(http.StatusUnprocessableEntity),
						Detail: fmt.Sprintf(
							"A request was made to operation 'QueryArrayOfOthers' but parameter '%s' was not properly sent - Expected %s but got %s",
							"values4",
							"[]int32",
							reflect.TypeOf(values4Raw).String(),
						),
						Status:     http.StatusUnprocessableEntity,
						Instance:   "/validation/error/QueryArrayOfOthers",
						Extensions: map[string]string{"error": conversionErr.Error()},
					}
					// params validation error response extension placeholder
					w.WriteHeader(http.StatusUnprocessableEntity)
					json.NewEncoder(w).Encode(validationError)
					return
				}
				values4Item := int32(values4Uint64)
				values4 = append(values4, int32(values4Item))
			}
			values4RawPtr = &values4
			values4RawPtr = &values4
		}
		if validatorErr := validatorInstance.Var(values4RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "values4"
			validationError := wrapValidatorError(validatorErr, "QueryArrayOfOthers", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.QueryArrayOfOthers(*valuesRawPtr, *values2RawPtr, *values3RawPtr, *values4RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'QueryArrayOfOthers'",
				Status:     statusCode,
				Instance:   "/controller/error/QueryArrayOfOthers",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/query-array-of-others-enum"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "QueryArrayOfOthersEnum")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var valuesRawPtr *[]Param31values.NumberEnum = nil
		valuesRawArray := req.URL.Query()["values"]
		isvaluesExists := req.URL.Query().Has("values")
		if isvaluesExists {
			values := make([]Param31values.NumberEnum, 0, len(valuesRawArray))
			for _, valuesRaw := range valuesRawArray {
				valuesUint64, conversionErr := strconv.ParseInt(valuesRaw, 10, 16)
				if conversionErr != nil {
					// Middlewares onInputValidationMiddlewares section
					for _, middleware := range onInputValidationMiddlewares {
						middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, conversionErr)
						setRequestContext(req, middlewareCtx)
						if !continueOperation {
							return
						}
					}
					// End middlewares onInputValidationMiddlewares section
					validationError := runtime.Rfc7807Error{
						Type: http.StatusText(http.StatusUnprocessableEntity),
						Detail: fmt.Sprintf(
							"A request was made to operation 'QueryArrayOfOthersEnum' but parameter '%s' was not properly sent - Expected %s but got %s",
							"values",
							"[]NumberEnum",
							reflect.TypeOf(valuesRaw).String(),
						),
						Status:     http.StatusUnprocessableEntity,
						Instance:   "/validation/error/QueryArrayOfOthersEnum",
						Extensions: map[string]string{"error": conversionErr.Error()},
					}
					// params validation error response extension placeholder
					w.WriteHeader(http.StatusUnprocessableEntity)
					json.NewEncoder(w).Encode(validationError)
					return
				}
				valuesItem := int16(valuesUint64)
				values = append(values, Param31values.NumberEnum(valuesItem))
			}
			valuesRawPtr = &values
			valuesVar := []Param31values.NumberEnum(values)
			valuesRawPtr = &valuesVar
		}
		if validatorErr := validatorInstance.Var(valuesRawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "values"
			validationError := wrapValidatorError(validatorErr, "QueryArrayOfOthersEnum", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		var values2RawPtr *[]Param32values2.BoolEnum = nil
		values2RawArray := req.URL.Query()["values2"]
		isvalues2Exists := req.URL.Query().Has("values2")
		if isvalues2Exists {
			values2 := make([]Param32values2.BoolEnum, 0, len(values2RawArray))
			for _, values2Raw := range values2RawArray {
				values2Item := values2Raw
				values2 = append(values2, Param32values2.BoolEnum(values2Item))
			}
			values2RawPtr = &values2
			values2Var := []Param32values2.BoolEnum(values2)
			values2RawPtr = &values2Var
		}
		if validatorErr := validatorInstance.Var(values2RawPtr, "required"); validatorErr != nil {
			// Middlewares onInputValidationMiddlewares section
			for _, middleware := range onInputValidationMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, validatorErr)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onInputValidationMiddlewares section
			fieldName := "values2"
			validationError := wrapValidatorError(validatorErr, "QueryArrayOfOthersEnum", fieldName)
			// validation error response extension placeholder
			w.WriteHeader(http.StatusUnprocessableEntity)
			json.NewEncoder(w).Encode(validationError)
			return
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.QueryArrayOfOthersEnum(*valuesRawPtr, *values2RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'QueryArrayOfOthersEnum'",
				Status:     statusCode,
				Instance:   "/controller/error/QueryArrayOfOthersEnum",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
	engine.HandleFunc(toMuxUrl("/e2e/query-pointer-to-array"), func(w http.ResponseWriter, req *http.Request) {
		// route start routes extension placeholder
		authErr := authorize(
			req,
			[]SecurityCheckList{
				{
					Relation: SecurityListRelationAnd,
					Checks: []runtime.SecurityCheck{
						{
							SchemaName: "securitySchemaName2",
							Scopes: []string{
								"config",
							},
						},
					},
				},
			},
		)
		if authErr != nil {
			handleAuthorizationError(w, authErr, "QueryArrayOfPointers")
			return
		}
		controller := E2EController.E2EController{}
		controller.InitController(req)
		var values07RawPtr *[]string = nil
		values07RawArray := req.URL.Query()["values07"]
		isvalues07Exists := req.URL.Query().Has("values07")
		if isvalues07Exists {
			values07 := make([]string, 0, len(values07RawArray))
			for _, values07Raw := range values07RawArray {
				values07Item := values07Raw
				values07 = append(values07, string(values07Item))
			}
			values07RawPtr = &values07
			values07RawPtr = &values07
		}
		// Middlewares beforeOperationMiddlewares section
		for _, middleware := range beforeOperationMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares beforeOperationMiddlewares section
		// before operation routes extension placeholder
		value, opError := controller.QueryArrayOfPointers(values07RawPtr)
		for key, value := range controller.GetHeaders() {
			w.Header().Set(key, value)
		}
		// response headers extension placeholder
		statusCode := getStatusCode(&controller, true, opError)
		if opError != nil {
			// Middlewares onErrorMiddlewares section
			for _, middleware := range onErrorMiddlewares {
				middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req, opError)
				setRequestContext(req, middlewareCtx)
				if !continueOperation {
					return
				}
			}
			// End middlewares onErrorMiddlewares section
			stdError := runtime.Rfc7807Error{
				Type:       http.StatusText(statusCode),
				Detail:     "Encountered an error during operation 'QueryArrayOfPointers'",
				Status:     statusCode,
				Instance:   "/controller/error/QueryArrayOfPointers",
				Extensions: map[string]string{"error": opError.Error()},
			}
			// json error response extension placeholder
			w.WriteHeader(statusCode)
			json.NewEncoder(w).Encode(stdError)
			return
		}
		// json response extension placeholder
		// Middlewares afterOperationSuccessMiddlewares section
		for _, middleware := range afterOperationSuccessMiddlewares {
			middlewareCtx, continueOperation := middleware(getRequestContext(req), w, req)
			setRequestContext(req, middlewareCtx)
			if !continueOperation {
				return
			}
		}
		// End middlewares afterOperationSuccessMiddlewares section
		// after operation routes extension placeholder
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		json.NewEncoder(w).Encode(value)
		// route end routes extension placeholder
	}).Methods("POST")
}
