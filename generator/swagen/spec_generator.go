package swagen

import (
	"context"
	"encoding/json"
	"os"
	"path/filepath"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gopher-fleece/gleece/definitions"
	"github.com/gopher-fleece/gleece/infrastructure/logger"
)

func appendErrorSchema(models *[]definitions.ModelMetadata, hasAnyErrorTypes bool) {
	if !hasAnyErrorTypes {
		return
	}
	(*models) = append((*models), definitions.ModelMetadata{
		Name:        definitions.Rfc7807ErrorName,
		Description: "A standard RFC-7807 error",
		Fields: []definitions.FieldMetadata{
			{
				Name:        "type",
				Type:        "string",
				Description: "A URI reference that identifies the problem type.",
				Tag:         `validate:"required"`,
			},
			{
				Name:        "title",
				Type:        "string",
				Description: "A short, human-readable summary of the problem type.",
				Tag:         `validate:"required"`,
			},
			{
				Name:        "status",
				Type:        "int",
				Description: "The HTTP status code generated by the origin server for this occurrence of the problem.",
				Tag:         `validate:"required"`,
			},
			{
				Name:        "detail",
				Type:        "string",
				Description: "A human-readable explanation specific to this occurrence of the problem.",
			},
			{
				Name:        "instance",
				Type:        "string",
				Description: "A URI reference that identifies the specific occurrence of the problem.",
			},
			{
				Name:        "error",
				Type:        "string",
				Description: "Error message",
			},
			{
				Name:        "extensions",
				Type:        "map[string]any",
				Description: "Additional metadata about the error.",
			},
		},
	})
}

// GenerateSpec generates the OpenAPI specification
func GenerateSpec(config *definitions.OpenAPIGeneratorConfig, defs []definitions.ControllerMetadata, models []definitions.ModelMetadata, hasAnyErrorTypes bool) ([]byte, error) {

	// Create a new OpenAPI specification using 3.0.0
	openapi := &openapi3.T{
		OpenAPI: "3.0.0",
		Info:    &config.Info,
		Servers: openapi3.Servers{
			{
				URL: config.BaseURL,
			},
		},
		Paths: openapi3.NewPaths(),
		Components: &openapi3.Components{
			Schemas: openapi3.Schemas{},
		},
	}

	// In case of a default error in use, add the RFC-7807, otherwise skip and assume the user define it using structs by themselves
	appendErrorSchema(&models, hasAnyErrorTypes)

	if err := GenerateSecuritySpec(openapi, &config.SecuritySchemes); err != nil {
		logger.Error("Failed to generate security spec - %v", err)
		return nil, err
	}
	logger.Info("Security spec generated successfully")

	if err := GenerateModelsSpec(openapi, models); err != nil {
		logger.Error("Failed to generate models spec - %v", err)
		return nil, err
	}
	logger.Info("Models spec generated successfully")

	if err := GenerateControllersSpec(openapi, config, defs); err != nil {
		logger.Error("Failed to generate controllers spec - %v", err)
		return nil, err
	}
	logger.Info("Controllers spec generated successfully")

	// Validate the spec to ensure it meets OpenAPI requirements
	if err := openapi.Validate(context.Background()); err != nil {
		logger.Error("Validation failed - %v", err.Error())
		return nil, err
	}
	logger.Info("OpenAPI specification validated successfully")

	// Convert the spec to JSON with indentation for easy reading
	jsonBytes, err := json.MarshalIndent(openapi, "", "  ")
	if err != nil {
		logger.Error("Marshalling error:", err)
		return nil, err
	}

	logger.Info("OpenAPI specification generation completed successfully")
	return jsonBytes, nil

}

func GenerateAndOutputSpec(config *definitions.OpenAPIGeneratorConfig, defs []definitions.ControllerMetadata, models []definitions.ModelMetadata, hasAnyErrorTypes bool) error {
	jsonBytes, err := GenerateSpec(config, defs, models, hasAnyErrorTypes)

	if err != nil {
		return err
	}

	// Extract path from file path
	// Extract the directory path
	dirPath := filepath.Dir(config.SpecGeneratorConfig.OutputPath)
	// Create the output directory if it doesn't exist
	if err := os.MkdirAll(dirPath, os.ModePerm); err != nil {
		logger.Error("Failed to create directory - %v", err)
		return err
	}

	// Write the JSON to the file
	if err := os.WriteFile(config.SpecGeneratorConfig.OutputPath, jsonBytes, 0644); err != nil {
		logger.Error("Failed to write file - %v", err)
		return err
	}

	// Print the path to the generated JSON file
	logger.Info("OpenAPI specification written to '%s'", config.SpecGeneratorConfig.OutputPath)
	return nil

}
