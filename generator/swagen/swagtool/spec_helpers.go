package swagtool

import (
	"strings"

	"github.com/gopher-fleece/gleece/definitions"
)

func AppendErrorSchema(models *[]definitions.StructMetadata, hasAnyErrorTypes bool) {
	if !hasAnyErrorTypes {
		return
	}
	(*models) = append((*models), definitions.StructMetadata{
		Name:        definitions.Rfc7807ErrorName,
		Description: "A standard RFC-7807 error",
		Fields: []definitions.FieldMetadata{
			{
				Name:        "type",
				Type:        "string",
				Description: "A URI reference that identifies the problem type.",
				Tag:         `validate:"required"`,
			},
			{
				Name:        "title",
				Type:        "string",
				Description: "A short, human-readable summary of the problem type.",
				Tag:         `validate:"required"`,
			},
			{
				Name:        "status",
				Type:        "int",
				Description: "The HTTP status code generated by the origin server for this occurrence of the problem.",
				Tag:         `validate:"required"`,
			},
			{
				Name:        "detail",
				Type:        "string",
				Description: "A human-readable explanation specific to this occurrence of the problem.",
			},
			{
				Name:        "instance",
				Type:        "string",
				Description: "A URI reference that identifies the specific occurrence of the problem.",
			},
			{
				Name:        "error",
				Type:        "string",
				Description: "Error message",
			},
			{
				Name:        "extensions",
				Type:        "map[string]any",
				Description: "Additional metadata about the error.",
			},
		},
	})
}

func IsPrimitiveType(typeName string) bool {
	switch typeName {
	case "string", "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "bool", "float32", "float64":
		return true
	default:
		return false
	}
}

func ToOpenApiType(typeName string) string {
	switch typeName {
	case "string":
		return "string"
	case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64":
		return "integer"
	case "bool":
		return "boolean"
	case "float32", "float64":
		return "number"
	case "[]byte", "bytes":
		return "binary"
	case "Time", "time.Time":
		return "date-time"
	default:
		if strings.HasPrefix(typeName, "[]") {
			return "array"
		}
		if strings.HasPrefix(typeName, "map[") {
			return "map"
		}
		return "object"
	}
}

func IsSecurityNameInSecuritySchemes(securitySchemes []definitions.SecuritySchemeConfig, securityName string) bool {
	for _, securityScheme := range securitySchemes {
		if securityScheme.SecurityName == securityName {
			return true
		}
	}
	return false
}

func IsHiddenAsset(hideOptions *definitions.MethodHideOptions) bool {
	if hideOptions == nil {
		return false
	}
	if hideOptions.Type == definitions.HideMethodNever {
		return false
	}
	if hideOptions.Type == definitions.HideMethodAlways {
		return true
	}

	// TODO: Check the condition...
	return false
}

func IsDeprecated(deprecationOptions *definitions.DeprecationOptions) bool {
	return deprecationOptions != nil && deprecationOptions.Deprecated
}

func HasEmbeddedField(fields []definitions.FieldMetadata) bool {
	for _, field := range fields {
		if field.IsEmbedded {
			return true
		}
	}
	return false
}

// GetTagValue extracts the value for a specific tag name from a struct tag string
// If the tag or value is not found, returns the default value
// Example usage:
//
//	tag := `json:"houseNumber" validate:"gte=1"`
//	jsonValue := GetTagValue(tag, "json", "default") // returns "houseNumber"
//	validateValue := GetTagValue(tag, "validate", "default") // returns "gte=1"
func GetTagValue(tagStr string, tagName string, defaultValue string) string {
	// Look for the requested tag
	prefix := tagName + ":\""

	// Find the start of the tag value
	start := strings.Index(tagStr, prefix)
	if start == -1 {
		return defaultValue
	}
	start += len(prefix)

	// Find the end of the tag value
	end := start
	for end < len(tagStr) && tagStr[end] != '"' {
		end++
	}

	// Extract and return the tag value
	if start < end {
		return tagStr[start:end]
	}

	// If tag value is empty, return default
	return defaultValue
}

// Since the json tag can have multiple values (e.g. `json: "name,omitempty"`), this function returns the first value as the name, only.
func GetJsonNameFromTag(tag string, defaultName string) string {
	fullTagValue := GetTagValue(tag, "json", defaultName)
	// Split by comma and return the first value
	return strings.Split(fullTagValue, ",")[0]
}

// IsGenericObject checks if the type should be represented as a generic object wihtout representation in the models collection in OpenAPI specification
// (e.g. map, any, interface{}, etc.)
func IsGenericObject(typeName string) bool {
	switch typeName {
	case "interface{}", "any", "":
		return true
	default:
		return false
	}
}

func IsFieldRequired(validationString string) bool {
	validationRules := strings.Split(validationString, ",")
	for _, rule := range validationRules {
		if rule == "required" {
			return true
		}
	}
	return false
}

// Helper function to determine the item type of an array
func GetArrayItemType(fieldType string) string {
	// Implement logic to extract the item type from the array type
	// For example, if fieldType is "[]string", return "string"
	return strings.TrimPrefix(fieldType, "[]")
}

func GetMapItemType(fieldType string) string {
	// Implement logic to extract the key and value types from the map type
	// For example, if fieldType is "map[string]int", return "string", "int"
	trimmed := strings.TrimPrefix(fieldType, "map[")
	trimmed = strings.TrimSuffix(trimmed, "]")
	parts := strings.SplitN(trimmed, "]", 2)
	if len(parts) != 2 {
		return "any"
	}
	return parts[1]
}
