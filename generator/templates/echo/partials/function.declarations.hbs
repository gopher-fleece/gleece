func getStatusCode(controller external.Controller, hasReturnValue bool, err error) int {
	if controller.GetStatus() != nil {
		return int(*controller.GetStatus())
	} 

	if err != nil {
		return http.StatusInternalServerError
	}

	if hasReturnValue {
		return http.StatusOK
	}

	return http.StatusNoContent
}

func bindAndValidateBody[TOutput any](ctx echo.Context, contentType string, output **TOutput) error {
	var err error

	bodyBytes, err := io.ReadAll(ctx.Request().Body)
	if err != nil {
		return err
	}

	var deserializedOutput TOutput

	switch contentType {
	case "application/json":
		err = json.Unmarshal(bodyBytes, &deserializedOutput)
	default:
		return fmt.Errorf("content-type %s is not currently supported by the validation subsystem", contentType)
	}

	if err != nil {
		return err
	}

	if err = validatorInstance.Struct(&deserializedOutput); err != nil {
		return err
	}

	*output = &deserializedOutput
	return nil
}

func toEchoUrl(url string) string {
	processedUrl := urlParamRegex.ReplaceAllString(url, ":$1")
	processedUrl = strings.ReplaceAll(processedUrl, "//", "/")
	if processedUrl == "" {
		return "/"
	}

	if !strings.HasPrefix(processedUrl, "/") {
		processedUrl = "/" + processedUrl
	}

	return processedUrl
}

func authorize(ctx echo.Context, checksLists []SecurityCheckList) *external.SecurityError {
	var lastError *external.SecurityError

	for _, list := range checksLists {
		if list.Relation != SecurityListRelationAnd {
			panic(
				"Encountered a security list relation of type '%s' - this is unexpected and indicates a bug in Gleece itself." +
					"Please open an issue at https://github.com/gopher-fleece/gleece/issues",
			)
		}

		// Iterate over each security list
		encounteredErrorInList := false
		for _, check := range list.Checks {
			secErr := RequestAuth.GleeceRequestAuthorization(ctx, check)
			if secErr != nil {
				lastError = secErr
				encounteredErrorInList = true
				break
			}
		}

		// If no error was encountered, validation is considered successful
		// otherwise, we continue over to the next iteration whilst keeping track of the last error
		if !encounteredErrorInList {
			return nil
		}
	}

	// If we got here it means authentication has failed
	return lastError
}

func handleAuthorizationError(ctx echo.Context, authErr *external.SecurityError, operationId string) error {
	statusCode := int(authErr.StatusCode)
	if authErr.CustomError != nil {
		// For now, we support JSON only
		return ctx.JSON(statusCode, authErr.CustomError.Payload)
		
	} 
	stdError := external.Rfc7807Error{
		Type:     http.StatusText(statusCode),
		Detail:   authErr.Message,
		Status:   statusCode,
		Instance: "/gleece/authorization/error/" + operationId,
	}
	return ctx.JSON(statusCode, stdError)
}